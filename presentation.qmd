---
title: "Caract√©risation et √©volution<br/>des pr√©cipitations extr√™mes horaires<br/>en France<br/>√† partir d‚Äôun mod√®le r√©gional de climat<br/>√† convection profonde r√©solue"
author: 
  - name: "<br/><br/>Decoopman Nicolas<br/>M2 math√©matiques et applications parcours statistique et science des donn√©es<br/><br/>---<br/>Encadrement<br/>Juliette Blanchet (CNRS, IGE) et Antoine Blanc (RTM)"
format:
  revealjs:
    theme: simple
    slide-number: true
    pdf-separate-fragments: false
    toc: false
    width: 1280
    height: 720
    self-contained: false 
    allow-scripts: true 
    css: presentation/styles.css
execute:
  cache: true
  echo: false
  warning: false
  message: false
  error: true
  freeze: auto  
jupyter: extremeprecipit
---


```{python}
%config InlineBackend.figure_format = 'svg'
%config InlineBackend.figure_dpi = 500
```

```{python}
import yaml
from pathlib import Path
from typing import Sequence, Mapping, Tuple, Optional

import pandas as pd
import polars as pl
import numpy as np
import geopandas as gpd
from shapely.geometry import box

import matplotlib.pyplot as plt
from matplotlib.colors import ListedColormap, BoundaryNorm, TwoSlopeNorm, Normalize, LinearSegmentedColormap
import plotly.express as px

from IPython.display import display, HTML, Markdown
import plotly.io as pio

import matplotlib as mpl

from app.utils.config_utils import menu_config_gev

from app.utils.data_utils import (
    match_and_compare,
    add_metadata,
    dont_show_extreme,
    standardize_year,
    filter_nan
)
from app.utils.stats_utils import generate_metrics

from app.pipelines.import_quarto import (
    pipeline_data_quarto, pipeline_data_gev_quarto,
    pipeline_map_quarto,
    pipeline_map_legend_scatter,
    pipeline_title, pipeline_show_html,
    pipeline_quarto_gev_half_france
)

# Charger les param√®tres depuis config.yaml
config_path = Path("app/config/config.yaml")
with open(config_path, "r") as f:
    config = yaml.safe_load(f)

def pipeline_total_title_map_legend_scatter_delta(
    title: str,
    year_min: int,
    year_max: int,
    echelle: str,
    html_map_legend: str,
    html_scatter: str,
    season_choice: str="hydro",
    me: int=None,
    percent: int=None,
    r2: int=None,
    unit: str=None,
    nb_after_comma: int=1
):
    if unit is None:
        unit = "mm/j" if echelle == "quotidien" else "mm/h"


    title_show = pipeline_title(title, year_min, year_max, echelle, season_choice)
    display(HTML(title_show))
    display(HTML(pipeline_show_html(html_map_legend, html_scatter)))
    
    if r2 is not None:
        display(HTML(f"r¬≤ = {r2:+.3f}"))
    elif me is not None:
        if percent is not None:
            display(HTML(f"Œî (AROME - Stations) : {me:+.{nb_after_comma}f} {unit} ({percent*100:+.1f}%)"))
        else:
            display(HTML(f"Œî (AROME - Stations) : {me:+.{nb_after_comma}f} {unit}"))
```


# Contexte


<!--l'air chaud contient plus d'humidit√© 

- **CP** (Convection-Permitting) : r√©soudre explicitement les processus de convection dans l'atmosph√®re (‚â† approximation)
    * Simuler plus pr√©cis√©ment la formation des nuages convectifs et des pr√©cipitations associ√©es

        * Donn√©es comme entr√©e ou condition initiale
    * Donn√©es pass√©es combinant des observations r√©elles avec des mod√®les
    * R√©solution 31 km, 1h, 137 niveaux d'atmosph√®re jusqu'√† 80 km d'altitude

    
**Permet d'√©tudier les pluies extr√™mes infra-journali√®res, difficiles √† voir dans les anciens mod√®les**
-->

<h2>R√©chauffement de la plan√®te</h2>

- Plus fort sur les continents que les oc√©ans (+1¬∞C monde, +1,7¬∞C France, +2¬∞C Alpes fran√ßaises)
- Clausius‚ÄìClapeyron (+7%/¬∞C)   
- L'air chaud monte, se refroidit, l'eau se condense sous forme de pluie
  
<h2>En r√©ponse au r√©chauffement</h2>

- Augmentation *th√©orique* des pr√©cipitations extr√™mes
- Variable suivant les changements de circulations atmosph√©riques

<h2>Utilisation de mod√®les de climat sur de longues p√©riodes</h2>

- Tendances durables (changement climatique) *vs.* variations naturelles (variabilit√© climatique)  
- Mod√®le num√©rique **A**pplication of **R**esearch to **O**perations at **ME**soscale  
- **C**onvection-**P**ermitting, **R**egional **C**limate **M**odel (2,5km - 1h), **forcer** par **r√©analyse** ERA5  



# M√©thodologie {.no-number}

![](presentation/methodologie.svg){width=100%}

---

<!--
# Evaluation des maxima

::: {.columns style="display: flex; gap: 0px; margin: 0;"}
::: {.column width="50%"}

```{python}
# Premier graphique (tirage al√©atoire pour illustrer)
rng = np.random.default_rng(12345)
years = np.arange(1990, 2023)
extremes1 = rng.normal(70, 25, years.size) + 0.6 * (years - 1959)
mean1 = extremes1.mean()

# Second graphique (diff√©rent tirage al√©atoire, pour illustrer)
rng = np.random.default_rng(54321)
extremes2 = rng.normal(70, 25, years.size) + 0.6 * (years - 1959)
mean2 = extremes2.mean()

# D√©finir des bornes communes pour l‚Äôaxe y
y_min = min(extremes1.min(), extremes2.min()) - 5
y_max = max(extremes1.max(), extremes2.max()) + 5

# Cr√©ation du graphique
plt.rcParams.update({
    "figure.dpi": 110,                        # meilleure d√©finition √©cran
})
fig, ax = plt.subplots(figsize=(8, 6))
ax.plot(years, extremes1, marker="o", color="#97a6c4", label="AROME")  # Premier jeu de donn√©es
ax.plot(years, extremes2, marker="s", color="#284860", label="Station")   # Deuxi√®me jeu de donn√©es
ax.axhline(mean1, linestyle="--", linewidth=1, color="#97a6c4")  # Ligne en pointill√©s pour la moyenne AROME 1
ax.axhline(mean2, linestyle="--", linewidth=1, color="#284860")   # Ligne en pointill√©s pour la moyenne AROME 2
# ‚Äî‚Äî‚Äî Masquer les 2 spines inutiles ‚Äî‚Äî‚Äî
ax.spines["top"].set_visible(False)
ax.spines["right"].set_visible(False)
ax.set_ylim(y_min, y_max)
plt.xlabel("Ann√©e")  # √âtiquette axe x
plt.ylabel("Pr√©cipitation maximale (mm/j)")  # √âtiquette axe y
plt.xticks(fontsize=10)  # Taille des ticks de l'axe x
plt.yticks(fontsize=10)  # Taille des ticks de l'axe y
plt.legend()  # L√©gende
plt.grid(False)  # Grille
plt.tight_layout()  # Ajustement du layout
plt.show()  # Affichage du graphique

```
:::

::: {.column width="50%"}
- La moyenne des maxima (- - -) : √©valuation *spatiale*  
- Les maxima annuels (---) : √©valuation *temporelle* 
:::

:::


# Niveau de retour $z_T$ 

Le seuil que l‚Äôon ne d√©passe **en moyenne** qu‚Äôune fois tous les $T$ ann√©es
<br/><br/>

::: {.columns style="display: flex; gap: 0px; margin: 0;"}
::: {.column width="50%"}
```{python}
from sklearn.linear_model import LinearRegression
extremes = [
    83.05, 69.90, 88.10, 90.31, 61.69, 68.48, 83.08, 78.94,
    82.23, 74.17, 91.79, 91.08, 84.26, 95.17, 88.88, 75.91,
    88.49, 75.51, 94.18, 85.20, 84.15, 79.49, 98.83, 85.35,
    82.92, 83.98, 93.12, 91.75, 92.53, 93.01,110.42, 85.24,
    84.48
]
years = np.arange(1990, 2023)

# Normalisation temporelle
t_tilde = (years - years.min()) / (years.max() - years.min())

# R√©gression lin√©aire
model = LinearRegression()
model.fit(t_tilde.reshape(-1, 1), extremes)
zT1 = model.coef_[0]

# Affichage
fig, ax = plt.subplots(figsize=(8, 6))
ax.plot(years, extremes, marker="o", color="#97a6c4", label="Maxima annuels")  # Premier jeu de donn√©es
ax.plot(years, model.predict(t_tilde.reshape(-1, 1)), linestyle="--",color="#284860", label=f"$z_{{T,1}} \\approx$ {zT1:.1f} mm soit {zT1*10/(years.max() - years.min()):.1f} mm/10 ans")   # Deuxi√®me jeu de donn√©es
# ‚Äî‚Äî‚Äî Masquer les 2 spines inutiles ‚Äî‚Äî‚Äî
ax.spines["top"].set_visible(False)
ax.spines["right"].set_visible(False)
plt.xlabel("Ann√©e")
plt.ylabel("Pr√©cipitation maximale (mm/j)")
plt.xticks(fontsize=10)  # Taille des ticks de l'axe x
plt.yticks(fontsize=10)  # Taille des ticks de l'axe y
plt.legend()  # L√©gende
plt.grid(False)  # Grille
plt.tight_layout()  # Ajustement du layout
plt.show()  # Affichage du graphique
```
:::

::: {.column width="50%"}
$$
z_T(t) = z_{T,0} + \mathbf{z_{T,1}} \cdot t
$$

$$
\begin{cases}
z_{T,1} > 0 & \text{les √©pisodes deviennent plus intenses} \\
z_{T,1} = 0 & \text{aucune tendance d√©tectable} \\
z_{T,1} < 0 & \text{les √©pisodes deviennent moins intenses}
\end{cases}
$$

On peut obtenir :

$$
z^{/10 \, ans}_{T,1} = \mathbf{z_{T,1}} \frac{10}{t_{max} - t_{min}}
$$
:::

:::

**Depuis 1990, le seuil correspondant √† un √©pisode de pluie extr√™me qu‚Äôon ne voit qu‚Äôune fois tous les 10 ans<br/>a augment√© de 4,7 mm tous les 10 ans.**



# R√©sultats statistiques descriptives

![](presentation/resultats-1.svg){width=100%}

-->

```{python}
#| label: jours_pluie_total
title="Nombre de jour de pluie moyen"
year_display_min = config["years"]["min"]
year_display_max = config["years"]["max"]
echelle="quotidien"

# √âtape 1 : r√©cup√©rer r√©sultats avec pipeline_data_quarto
result = pipeline_data_quarto(
    config=config,
    stat_choice="numday",
    echelle=echelle,
    min_year=year_display_min,
    max_year=year_display_max,
    season_choice="hydro",
    unit_choice="jours",
    missing_choice=0.10,
    quantile_choice=0.995
)

# √âtape 2 : affichage carte + scatter
html_map_legend, html_scatter, r2, me, n, percent = pipeline_map_legend_scatter(
    name="jour_pluie_total",
    result=result,
    echelle=echelle,
    stat_choice_label=title,
    missing_choice=0.10,
    unit_choice="jours"
)

pipeline_total_title_map_legend_scatter_delta(
    title=title,
    year_min=year_display_min,
    year_max=year_display_max,
    echelle=echelle,
    html_map_legend=html_map_legend,
    html_scatter=html_scatter,
    me=me,
    percent=percent,
    unit="jours"
)
```

<br/>**Tendance √† d√©clencher des jours de pluie plus fr√©quemment que ce qui est observ√©**


```{python}
# #| label: jours_pluie_2000_MAX
# year_display_min = 1990
# year_display_max = config["years"]["max"]
# echelle="quotidien"

# # √âtape 1 : r√©cup√©rer les r√©sultats avec pipeline_data_quarto
# result = pipeline_data_quarto(
#     config=config,
#     stat_choice="numday",
#     echelle=echelle,
#     min_year=year_display_min,
#     max_year=year_display_max,
#     season_choice="hydro",
#     unit_choice="jours",
#     missing_choice=0.10,
#     quantile_choice=0.995
# )

# # √âtape 2 : affichage carte + scatter
# html_map_legend, html_scatter, r2, me, n, percent = pipeline_map_legend_scatter(
#     name="jour_pluie_2000",
#     result=result,
#     echelle=echelle,
#     stat_choice_label="Jour de pluie",
#     missing_choice=0.10,
#     unit_choice="jours"
# )

# pipeline_total_title_map_legend_scatter_delta(
#     title=title,
#     year_min=year_display_min,
#     year_max=year_display_max,
#     echelle=echelle,
#     html_map_legend=html_map_legend,
#     html_scatter=html_scatter,
#     me=me,
#     percent=percent,
#     unit="jours"
# )
```


---

```{python}
#| label: moy_precipit_jour_total
title="Cumul des pr√©cipitations"
year_display_min = config["years"]["min"]
year_display_max = config["years"]["max"]
echelle="quotidien"

# √âtape 1 : r√©cup√©rer les r√©sultats avec pipeline_data_quarto
result = pipeline_data_quarto(
    config=config,
    stat_choice="mean",
    echelle=echelle,
    min_year=year_display_min,
    max_year=year_display_max,
    season_choice="hydro",
    missing_choice=0.10,
    quantile_choice=0.995
)

# √âtape 2 : affichage carte + scatter
html_map_legend, html_scatter, r2, me, n, percent = pipeline_map_legend_scatter(
    name="jour_mean_total",
    result=result,
    echelle=echelle,
    missing_choice=0.10,
    stat_choice_label="Moyenne des pr√©cipitations"
)

pipeline_total_title_map_legend_scatter_delta(
    title=title,
    year_min=year_display_min,
    year_max=year_display_max,
    echelle=echelle,
    html_map_legend=html_map_legend,
    html_scatter=html_scatter,
    me=me,
    percent=percent,
    nb_after_comma=3
)
```

```{python}
#| label: moy_precipit_jour_2000_MAX_only_metric
# year_display_min = 1990
# year_display_max = config["years"]["max"]
# echelle="quotidien"

# # √âtape 1 : r√©cup√©rer les r√©sultats avec pipeline_data_quarto
# result = pipeline_data_quarto(
#     config=config,
#     stat_choice="mean",
#     echelle=echelle,
#     min_year=year_display_min,
#     max_year=year_display_max,
#     season_choice="hydro",
#     missing_choice=0.10,
#     quantile_choice=0.995
# )

# # √âtape 2 : affichage carte + scatter
# _, _, _, me, _, percent = pipeline_map_legend_scatter(
#     name="jour_mean_2000",
#     result=result,
#     echelle=echelle,
#     missing_choice=0.10,
#     stat_choice_label="Moyenne des pr√©cipitations"
# )
# display(HTML(f"Œî (AROME - Stations) de {year_display_min} √† {year_display_max} : {me:+.3f} mm/j ({percent*100:+.1f}%)"))
```

**R√©partition correcte de la quantit√© totale d‚Äôeau**

---

```{python}
#| label: moy_precipit_horaire_2000_MAX
year_display_min = 1990
year_display_max = config["years"]["max"]
echelle="horaire"

# √âtape 1 : r√©cup√©rer les r√©sultats avec pipeline_data_quarto
result = pipeline_data_quarto(
    config=config,
    stat_choice="mean",
    echelle=echelle,
    min_year=year_display_min,
    max_year=year_display_max,
    season_choice="hydro",
    missing_choice=0.10,
    quantile_choice=0.995
)

# √âtape 2 : affichage carte + scatter
html_map_legend, html_scatter, r2, me, n, percent = pipeline_map_legend_scatter(
    name="horaire_mean_2000",
    result=result,
    echelle=echelle,
    missing_choice=0.10,
    stat_choice_label="Moyenne des pr√©cipitations"
)

pipeline_total_title_map_legend_scatter_delta(
    title=title,
    year_min=year_display_min,
    year_max=year_display_max,
    echelle=echelle,
    html_map_legend=html_map_legend,
    html_scatter=html_scatter,
    me=me,
    percent=percent,
    nb_after_comma=3
)
```

<br/>**R√©sultat semblable**

---

<h2>Pluies plus fr√©quentes en plus faibles quantit√©s</h2>

![](presentation/bilan-1.svg){width=100%}


---

```{python}
#| label: moy_max_precipit_jour_total
title="Moyenne des maxima des pr√©cipitations"
year_display_min = config["years"]["min"]
year_display_max = config["years"]["max"]
echelle="quotidien"

# √âtape 1 : r√©cup√©rer les r√©sultats avec pipeline_data_quarto
result = pipeline_data_quarto(
    config=config,
    stat_choice="mean-max",
    echelle=echelle,
    min_year=year_display_min,
    max_year=year_display_max,
    season_choice="hydro",
    missing_choice=0.10,
    quantile_choice=0.995
)

# √âtape 2 : affichage carte + scatter
html_map_legend, html_scatter, r2, me, n, percent = pipeline_map_legend_scatter(
    name="jour_mean_max_total",
    result=result,
    echelle=echelle,
    missing_choice=0.10,
    stat_choice_label="Moyenne des maxima"
)

pipeline_total_title_map_legend_scatter_delta(
    title=title,
    year_min=year_display_min,
    year_max=year_display_max,
    echelle=echelle,
    html_map_legend=html_map_legend,
    html_scatter=html_scatter,
    me=me,
    percent=percent,
    nb_after_comma=3
)
```

```{python}
#| label: moy_max_precipit_jour_2000_MAX
# year_display_min = 1990
# year_display_max = config["years"]["max"]
# echelle="quotidien"

# # √âtape 1 : r√©cup√©rer les r√©sultats avec pipeline_data_quarto
# result = pipeline_data_quarto(
#     config=config,
#     stat_choice="mean-max",
#     echelle=echelle,
#     min_year=year_display_min,
#     max_year=year_display_max,
#     season_choice="hydro",
#     missing_choice=0.10,
#     quantile_choice=0.995
# )

# # √âtape 2 : affichage carte + scatter
# _, _, _, me, _, percent = pipeline_map_legend_scatter(
#     name="jour_mean_max_2000",
#     result=result,
#     echelle=echelle,
#     missing_choice=0.10,
#     stat_choice_label="Moyenne des maxima"
# )

# display(HTML(f"Œî (AROME - Stations) de {year_display_min} √† {year_display_max} : {me:+.3f} mm/j ({percent*100:+.1f}%)"))
```

---

```{python}
#| label: moy_max_precipit_horaire_2000_MAX
year_display_min = 1990
year_display_max = config["years"]["max"]
echelle="horaire"

# √âtape 1 : r√©cup√©rer les r√©sultats avec pipeline_data_quarto
result = pipeline_data_quarto(
    config=config,
    stat_choice="mean-max",
    echelle=echelle,
    min_year=year_display_min,
    max_year=year_display_max,
    season_choice="hydro",
    missing_choice=0.10,
    quantile_choice=0.995
)

# √âtape 2 : affichage carte + scatter
html_map_legend, html_scatter, r2, me, n, percent = pipeline_map_legend_scatter(
    name="horaire_mean_max_2000",
    result=result,
    echelle=echelle,
    missing_choice=0.10,
    stat_choice_label="Moyenne des maxima"
)

pipeline_total_title_map_legend_scatter_delta(
    title=title,
    year_min=year_display_min,
    year_max=year_display_max,
    echelle=echelle,
    html_map_legend=html_map_legend,
    html_scatter=html_scatter,
    me=me,
    percent=percent,
    nb_after_comma=3
)
```


---


```{python}
# | label: moyenne-max_vs_series-max
# suppresion de l'affichage ici
year_display_min = config["years"]["min"]
year_display_max = config["years"]["max"]
echelle="quotidien"
title="Comparaison de la moyenne des maxima aux maxima annuels des pr√©cipitations"
title_show = pipeline_title(title, year_display_min, year_display_max, echelle)

# --------------- VALEURS MOYENNES
result = pipeline_data_quarto(
    config=config,
    stat_choice="mean-max",
    echelle=echelle,
    min_year=year_display_min,
    max_year=year_display_max,
    season_choice="hydro",
    missing_choice=0.10,
    quantile_choice=0.995
)

_, html_scatter_mean, r2_mean, me_mean, n_mean, _ = pipeline_map_legend_scatter(
    name="jour_mean_max_total",
    result=result,
    echelle=echelle,
    missing_choice=0.10,
    stat_choice_label="Moyenne des maxima"
)
```



```{python}
#  --------------- MAX ANNNUELS
from app.modules import all_max
from app.utils.scatter_plot_utils import generate_scatter_plot_interactive
from app.utils.stats_utils import generate_metrics

year_display_min = config["years"]["min"]
year_display_max = config["years"]["max"]
missing_choice=0.10
year_display_middle, height, unit_choice = 1990, 500, "mm/j"
df_all, df_r2_all_max = all_max.show(config_path, year_display_min, year_display_max, year_display_middle, missing_choice)
df_all = df_all.rename({"lat_obs": "lat", "lon_obs": "lon"})

# Ajout du scatter plot pour AROME vs station annuels
fig_r2_all_max_hydro_jour = generate_scatter_plot_interactive(
    df=df_all,
    stat_choice="",
    unit_label=unit_choice,
    height=height-60
)

fig_r2_all_max_hydro_jour.update_layout(
    template="simple_white",
    margin=dict(l=100, r=0, t=50, b=50),
    xaxis=dict(title=dict(text=f"AROME ({unit_choice})"), showticklabels=True),
    yaxis=dict(title=dict(text=f"Stations ({unit_choice})"), showticklabels=True)
)

me_all, _, _, r2_all = generate_metrics(df_all)
scatter_path = "assets/fig_r2_all_max_hydro_jour.html"
pio.write_html(fig_r2_all_max_hydro_jour, file=scatter_path, include_plotlyjs="cdn", full_html=False)
```

<!-- ::: {.columns style="display: flex; gap: 0px; margin: 0;"}
::: {.column width="50%"}
```{python}
display(HTML(title_show))
display(HTML('<div style="text-align: center; font-weight: bold;">Moyenne des maxima</div>'))
display(HTML(html_scatter_mean))
```
:::
::: {.column width="50%"}
```{python}
display(HTML('<div style="text-align: center; font-weight: bold;">Maxima annuels</div>'))
display(HTML(f"""
     <div style="height: {height-10}px; border: 1px solid #ccc; border-radius: 6px; display: flex; align-items: center; justify-content: center; overflow: hidden; margin-top: 10px;">
         <iframe loading="lazy" src="{scatter_path}" width="100%" height="100%" frameborder="0" style="flex: 3; width: 0; min-width: 0; max-width: 100%;"></iframe>
     </div>

     <div class="metric-caption">
         <strong>r¬≤</strong> = {r2_all:.3f} &nbsp;|&nbsp; <strong>ME</strong> = {me_all:.3f} &nbsp;|&nbsp; <strong>n</strong> = {df_all.shape[0]:.0f}
     </div>
 """))
```
:::
:::
-->

```{python}
title = "Maxima annuels des pr√©cipitations suivant la saison et l'√©chelle temporelle"
display(HTML(f"""
    <div style="font-size: 18px; color: #333;">
        <p style="font-size: 22px; font-weight: bold; color: #2c3e50;">{title}</p>
        <p style="font-size: 18px; color: #3498db;">
            de <span style="font-weight: bold; color: #e74c3c;">{year_display_min}</span> √† <span style="font-weight: bold; color: #e74c3c;">{year_display_max}</span> 
            pour l'√©chelle : <span style="font-weight: bold; color: #f39c12;">quotidien</span>
            et de <span style="font-weight: bold; color: #e74c3c;">{year_display_middle}</span> √† <span style="font-weight: bold; color: #e74c3c;">{year_display_max}</span> 
            pour l'√©chelle : <span style="font-weight: bold; color: #f39c12;">horaire</span>
        </p> 
    </div>    
"""))
```

::: {.columns style="display: flex; gap: 0px; margin: 0;"}
::: {.column width="40%"}

```{python}
# Premier graphique (tirage al√©atoire pour illustrer)
rng = np.random.default_rng(12345)
years = np.arange(1990, 2023)
extremes1 = rng.normal(70, 25, years.size) + 0.6 * (years - 1959)
mean1 = extremes1.mean()

# Second graphique (diff√©rent tirage al√©atoire, pour illustrer)
rng = np.random.default_rng(54321)
extremes2 = rng.normal(70, 25, years.size) + 0.6 * (years - 1959)
mean2 = extremes2.mean()

# D√©finir des bornes communes pour l‚Äôaxe y
y_min = min(extremes1.min(), extremes2.min()) - 5
y_max = max(extremes1.max(), extremes2.max()) + 5

# Cr√©ation du graphique
plt.rcParams.update({
    "figure.dpi": 110,                        # meilleure d√©finition √©cran
})
fig, ax = plt.subplots(figsize=(6, 6))
ax.plot(years, extremes1, marker="o", color="#97a6c4", label="AROME")  # Premier jeu de donn√©es
ax.plot(years, extremes2, marker="s", color="#284860", label="Station")   # Deuxi√®me jeu de donn√©es
ax.axhline(mean1, linestyle="--", linewidth=1, color="#97a6c4")  # Ligne en pointill√©s pour la moyenne AROME 1
ax.axhline(mean2, linestyle="--", linewidth=1, color="#284860")   # Ligne en pointill√©s pour la moyenne AROME 2
# ‚Äî‚Äî‚Äî Masquer les 2 spines inutiles ‚Äî‚Äî‚Äî
ax.spines["top"].set_visible(False)
ax.spines["right"].set_visible(False)
ax.set_ylim(y_min, y_max)
plt.xlabel("")  # √âtiquette axe x
plt.ylabel("Pr√©cipitation maximale (mm/j)")  # √âtiquette axe y
plt.tick_params(axis='y', labelsize=10)
plt.xticks(fontsize=10)  # Taille des ticks de l'axe x
plt.yticks(fontsize=10)  # Taille des ticks de l'axe y
plt.legend()  # L√©gende
plt.grid(False)  # Grille
plt.tight_layout()  # Ajustement du layout
plt.show()  # Affichage du graphique
```
:::

::: {.column width="60%"}


```{python}
#| label: moyenne-max_vs_series-max_ALL
afficher_cat = [
    f"Journali√®re ({year_display_min}-{year_display_max})", f"Journali√®re ({year_display_middle}-{year_display_max})",
    "1h", "3h glissante", "6h glissante", "9h glissante", "12h glissante", "24h glissante", "1h (agreg 3x3)", "1h (agreg 5x5)"
    ]

# D√©finir une palette manuelle coh√©rente
color_map = {
    f"Journali√®re ({year_display_min}-{year_display_max})": "#17becf",       # Bleu clair
    f"Journali√®re ({year_display_middle}-{year_display_max})": "#1f77b4",       # Bleu (Plotly[0])
    "1h": "#ff7f0e",                # Orange (Plotly[1])
    "3h glissante": "#2ca02c",      # Vert (Plotly[2])
    "6h glissante": "#d62728",      # Rouge (Plotly[3])
    "9h glissante": "#9467bd",      # Violet (Plotly[4])
    "12h glissante": "#8c564b",     # Marron (Plotly[5])
    "24h glissante": "#e377c2",     # Rose (Plotly[6])
    "1h (agreg 3x3)": "#ff9f4e",    # Orange l√©g√®rement ajust√©
    "1h (agreg 5x5)": "#fff44f",       # jaune pastel
}
    

# refaire la cat√©gorisation et le plotting sur cette nouvelle colonne
afficher_cat_lbl = [f"{cat}" 
                    for cat in afficher_cat]

df_r2_all_max["Echelle_lbl"] = pd.Categorical(
    df_r2_all_max["Echelle"], 
    categories=afficher_cat_lbl, 
    ordered=True
)

df_r2_all_max["Echelle"] = pd.Categorical(df_r2_all_max["Echelle"], categories=afficher_cat, ordered=True)
df_r2_all_max["r2_txt"] = df_r2_all_max["r¬≤"].apply(lambda x: f"{x:.2f}".lstrip("0"))
df_r2_all_max["ME_txt"] = df_r2_all_max["ME"].apply(lambda x: f"{x:.2f}".lstrip("0"))


# S√©lectionner uniquement les donn√©es pour "Maxima annuels"
df_r2_all_max = df_r2_all_max[df_r2_all_max["Type"] == "Maxima annuels"]

# Cr√©ation de la figure avec px.bar
fig_r2_all_max = px.bar(
    df_r2_all_max,
    x="Saison",
    y="r¬≤",
    text="r2_txt",
    color="Echelle",
    custom_data=["Stations"],            
    barmode="group",
    facet_col="Type",
    category_orders={"Echelle": afficher_cat},
    title="",
    facet_col_spacing=0.01,
    height=440
)

# Positionner le texte √† l'ext√©rieur des barres
fig_r2_all_max.update_traces(
    textfont=dict(size=10),  # r√©duit la taille du texte √† 10 px
    texttemplate="%{text}<br>%{customdata[0]}",  # Afficher uniquement la partie d√©cimale comme .93, .41, etc.
    textposition="outside",  # Positionner le texte √† l'ext√©rieur de la barre
    insidetextanchor="start"  # Assure que le texte est bien visible √† l'ext√©rieur
)

fig_r2_all_max.update_layout(
    template="simple_white",
    legend_title_text=""  # Ajout du titre √† la l√©gende
)
fig_r2_all_max.update_xaxes(title=None, tickangle=0)

# Appliquer la couleur √† chaque trace selon son nom de l√©gende
for trace in fig_r2_all_max.data:
    trace.marker.color = color_map.get(trace.name, "#888888")

fig_r2_path = f"assets/fig_r2_all_max.html"
pio.write_html(fig_r2_all_max, file=fig_r2_path, include_plotlyjs="cdn", full_html=False)

display(HTML(f"""
    <div style="height: {height-10}px; border: 1px solid #ccc; border-radius: 6px; display: flex; align-items: center; justify-content: center; overflow: hidden; margin-top: 10px;">
        <iframe loading="lazy" src="{fig_r2_path}" width="100%" height="100%" frameborder="0" style="flex: 3; width: 0; min-width: 0; max-width: 100%;"></iframe>
    </div>
"""))

# Cr√©ation de la figure avec px.bar
# fig_me_all_max = px.bar(
#     df_r2_all_max,
#     x="Saison",
#     y="ME",
#     color="Echelle",  # Utiliser "Echelle" pour la couleur
#     text="ME_txt",
#     barmode="group",
#     facet_col="Type",  # Facet par "Type" (Moyenne des maxima, Maxima annuels)
#     category_orders={"Echelle": afficher_cat},
#     title="",
#     facet_col_spacing=0.01,
#     height=450
# )

# # Positionner le texte √† l'ext√©rieur des barres
# fig_me_all_max.update_traces(
#     textfont=dict(size=7),  # r√©duit la taille du texte √† 10 px
#     texttemplate="%{text}",  # Afficher uniquement la partie d√©cimale comme .93, .41, etc.
#     textposition="outside",  # Positionner le texte √† l'ext√©rieur de la barre
#     insidetextanchor="start"  # Assure que le texte est bien visible √† l'ext√©rieur
# )

# fig_me_all_max.update_layout(
#     template="simple_white",
#     legend_title_text="Pas de temps"  # Ajout du titre √† la l√©gende
# )
# fig_me_all_max.update_xaxes(title=None, tickangle=0)

# # Appliquer la couleur √† chaque trace selon son nom de l√©gende
# for trace in fig_me_all_max.data:
#     trace.marker.color = color_map.get(trace.name, "#888888")

# fig_me_path = f"assets/fig_me_all_max.html"
# pio.write_html(fig_me_all_max, file=fig_me_path, include_plotlyjs="cdn", full_html=False)

```

:::

:::

<br/><br/>
**R√©partition des orages dans le temps jamais tr√®s bonne**

---

<h2>Bonne distribution et difficult√© √©v√®nementielle</h2>

![](presentation/bilan-2.svg){width=100%}

<!--

# R√©sultats mod√©lisation

![](presentation/resultats-2.svg){width=100%}

---



# Application GEV (Œº, œÉ, Œæ)

```{python}
#| label: define_gev
# Liste compl√®te des mod√®les avec leurs √©quations explicites
model_options = {
    "M‚ÇÄ(Œº‚ÇÄ, œÉ‚ÇÄ) : Œº(t) = Œº‚ÇÄ ; œÉ(t) = œÉ‚ÇÄ ; Œæ(t) = Œæ": "s_gev",
    "M‚ÇÅ(Œº, œÉ‚ÇÄ) : Œº(t) = Œº‚ÇÄ + Œº‚ÇÅ¬∑t ; œÉ(t) = œÉ‚ÇÄ ; Œæ(t) = Œæ": "ns_gev_m1",
    "M‚ÇÇ(Œº‚ÇÄ, œÉ) : Œº(t) = Œº‚ÇÄ ; œÉ(t) = œÉ‚ÇÄ + œÉ‚ÇÅ¬∑t ; Œæ(t) = Œæ": "ns_gev_m2",
    "M‚ÇÉ(Œº, œÉ) : Œº(t) = Œº‚ÇÄ + Œº‚ÇÅ¬∑t ; œÉ(t) = œÉ‚ÇÄ + œÉ‚ÇÅ¬∑t ; Œæ(t) = Œæ": "ns_gev_m3",
    "M‚ÇÅ‚ãÜ(Œº, œÉ‚ÇÄ) : Œº(t) = Œº‚ÇÄ + Œº‚ÇÅ¬∑t‚Çä ; œÉ(t) = œÉ‚ÇÄ ; Œæ(t) = Œæ en notant t‚Çä = t ¬∑ ùüô_{t > t‚ÇÄ} avec t‚ÇÄ = 1985": "ns_gev_m1_break_year",
    "M‚ÇÇ‚ãÜ(Œº‚ÇÄ, œÉ) : Œº(t) = Œº‚ÇÄ ; œÉ(t) = œÉ‚ÇÄ + œÉ‚ÇÅ¬∑t‚Çä ; Œæ(t) = Œæ en notant t‚Çä = t ¬∑ ùüô_{t > t‚ÇÄ} avec t‚ÇÄ = 1985": "ns_gev_m2_break_year",
    "M‚ÇÉ‚ãÜ(Œº, œÉ) : Œº(t) = Œº‚ÇÄ + Œº‚ÇÅ¬∑t‚Çä ; œÉ(t) = œÉ‚ÇÄ + œÉ‚ÇÅ¬∑t‚Çä ; Œæ(t) = Œæ en notant t‚Çä = t ¬∑ ùüô_{t > t‚ÇÄ} avec t‚ÇÄ = 1985": "ns_gev_m3_break_year",
}
model_labels = {v: k.split(" :")[0] for k, v in model_options.items()}


# Repr√©sentation graphique de GEV classiques
import matplotlib.pyplot as plt
from scipy.stats import genextreme

# D√©finir la grille x
x = np.linspace(-10, 20, 1000)

# Param√®tres √† illustrer
mu_values = [-5, 0, 5]
sigma_values = [1, 2, 4]
xi_values = [-0.5, 0.0, 0.5]

# Cr√©ation de la figure avec 3 colonnes
fig, axes = plt.subplots(1, 3, figsize=(15, 4), constrained_layout=True)

# Style √©pur√© sans ticks num√©riques, mais avec axes visibles
for ax in axes:
    # Affiche les axes (left et bottom)
    ax.spines['left'].set_visible(True)
    ax.spines['bottom'].set_visible(True)
    # Supprime top et right
    ax.spines['top'].set_visible(False)
    ax.spines['right'].set_visible(False)
    # Supprime les ticks chiffr√©s
    ax.set_xticks([])
    ax.set_yticks([])
    ax.tick_params(left=False, bottom=False, labelleft=False, labelbottom=False)

# 1. Effet de Œº
for mu in mu_values:
    y = genextreme.pdf(x, c=-0.1, loc=mu, scale=2)
    axes[0].plot(x, y, label=f"$\\mu$ = {mu}")
axes[0].set_title("Effet de $\\mu$ (position)", loc='right')
axes[0].set_xlabel("x")
axes[0].set_ylabel("Densit√©")
axes[0].legend(frameon=False, fontsize=9)

# 2. Effet de œÉ
for sigma in sigma_values:
    y = genextreme.pdf(x, c=-0.1, loc=0, scale=sigma)
    axes[1].plot(x, y, label=f"$\\sigma$ = {sigma}")
axes[1].set_title("Effet de $\\sigma$ (√©chelle)", loc='right')
axes[1].set_xlabel("x")
axes[1].legend(frameon=False, fontsize=9)

# 3. Effet de Œæ
for xi in xi_values:
    y = genextreme.pdf(x, c=-xi, loc=0, scale=2)
    axes[2].plot(x, y, label=f"$\\xi$ = {xi}")
axes[2].set_title("Effet de $\\xi$ (forme)", loc='right')
axes[2].set_xlabel("x")
axes[2].legend(frameon=False, fontsize=9)

plt.show()
```

---

### Mod√®les sans rupture temporelle

| Mod√®le | Œº(t)              | œÉ(t)              | Œæ(t) |
|:------:|:------------------|:------------------|:-----:|
| M‚ÇÄ     | Œº‚ÇÄ                | œÉ‚ÇÄ                | Œæ    |
| M‚ÇÅ     | Œº‚ÇÄ¬†+¬†Œº‚ÇÅ¬∑t         | œÉ‚ÇÄ                | Œæ    |
| M‚ÇÇ     | Œº‚ÇÄ                | œÉ‚ÇÄ¬†+¬†œÉ‚ÇÅ¬∑t         | Œæ    |
| M‚ÇÉ     | Œº‚ÇÄ¬†+¬†Œº‚ÇÅ¬∑t         | œÉ‚ÇÄ¬†+¬†œÉ‚ÇÅ¬∑t         | Œæ    |


### Mod√®les avec rupture en 1985

<span style="font-size: 1.05em;">Soit</span>
**t‚Çä¬†=¬†t¬†√ó¬†ùüô{t¬†&gt;¬†1985}**,
on a :

| Mod√®le         | Œº(t)                 | œÉ(t)                 | Œæ(t) |
|:--------------:|:---------------------|:---------------------|:-----:|
| M‚ÇÅ‚ãÜ (rupture)  | Œº‚ÇÄ¬†+¬†Œº‚ÇÅ¬∑t‚Çä           | œÉ‚ÇÄ                   | Œæ    |
| M‚ÇÇ‚ãÜ (rupture)  | Œº‚ÇÄ                   | œÉ‚ÇÄ¬†+¬†œÉ‚ÇÅ¬∑t‚Çä           | Œæ    |
| M‚ÇÉ‚ãÜ (rupture)  | Œº‚ÇÄ¬†+¬†Œº‚ÇÅ¬∑t‚Çä           | œÉ‚ÇÄ¬†+¬†œÉ‚ÇÅ¬∑t‚Çä           | Œæ    |



---

```{python}
#| label: minimize_gev_aic_map
echelle = "quotidien"
season = "son"
title = f"Mod√®le minimisant l'AIC"
mod_dir = Path(config["gev"]["modelised"]) / echelle / season
obs_dir = Path(config["gev"]["observed"]) / echelle / season

df_model_aic = pl.read_parquet(mod_dir / "gev_param_best_model.parquet")
df_obs_aic = pl.read_parquet(obs_dir / "gev_param_best_model.parquet")

df_model_aic = add_metadata(df_model_aic, "mm_h" if echelle == "horaire" else "mm_j", type="modelised")
df_obs_aic = add_metadata(df_obs_aic, "mm_h" if echelle == "horaire" else "mm_j", type="observed")

df_model_aic = filter_nan(df_model_aic, "xi") # xi est toujours valable
df_obs_aic = filter_nan(df_obs_aic, "xi") # xi est toujours valable

df_model_aic = df_model_aic.with_columns(
    pl.col("model").replace(model_labels)  # remplace par noms lisibles
)
df_obs_aic = df_obs_aic.with_columns(
    pl.col("model").replace(model_labels)
)

result = {
    "modelised": df_model_aic,
    "modelised_show": df_model_aic,
    "observed": df_obs_aic,
    "observed_show": df_obs_aic,
    "column": "model",
    "echelle": "diverging_zero_white",
    "continu": False,
    "categories": list(model_labels.values())  # ["M‚ÇÅ(Œº‚ÇÄ, œÉ‚ÇÄ)", "M‚ÇÇ(Œº, œÉ‚ÇÄ)", ...]
}

html_map_legend = pipeline_map_quarto(
    name="model_minim_AIC",
    result=result,
    echelle=echelle,
    stat_choice_label=None,
    unit_choice=""
)

title_show = pipeline_title(title, config["years"]["min"], config["years"]["max"], echelle, season)
display(HTML(title_show))
```

::: {.columns style="display: flex; gap: 0px; margin: 0;"}
::: {.column width="50%"}
```{python}
display(HTML(html_map_legend))
```
:::

```{python}
#| label: minimize_gev_aic_hist
import plotly.graph_objects as go

# Mapping des noms vers leur affichage en unicode/math
param_display = {
    "mu0": "Œº‚ÇÄ",
    "mu1": "Œº‚ÇÅ",
    "sigma0": "œÉ‚ÇÄ",
    "sigma1": "œÉ‚ÇÅ",
    "xi": "Œæ"
}

df_model_aic = df_model_aic.with_columns(pl.col("NUM_POSTE").cast(pl.Int32))
df_obs_aic = df_obs_aic.with_columns(pl.col("NUM_POSTE").cast(pl.Int32))
df_obs_vs_mod_full = pl.read_csv(f"data/metadonnees/obs_vs_mod/obs_vs_mod_{echelle}.csv")

r2_values = {}
params = ["mu0", "mu1", "sigma0", "sigma1", "xi"]

for param in params:
    obs_vs_mod = match_and_compare(df_obs_aic, df_model_aic, param, df_obs_vs_mod_full)

    if obs_vs_mod is not None and obs_vs_mod.height > 0:
        _, _, _, r2 = generate_metrics(obs_vs_mod)
        r2_values[param_display[param]] = r2
    else:
        r2_values[param_display[param]] = None  # ou np.nan si tu pr√©f√®res

# Pr√©paration des donn√©es pour l'histogramme
labels = list(r2_values.keys())
values = [r2_values[label] if r2_values[label] is not None else 0 for label in labels]
colors = ["grey" if r2_values[label] is not None else "white" for label in labels]

# Cr√©ation de la figure Plotly
fig_r2_all_max = go.Figure(data=[
    go.Bar(x=labels, y=values, marker_color=colors, text=[f"{v:.3f}" if r2_values[l] is not None else "NA" for l, v in zip(labels, values)],
           textposition="outside")
])

fig_r2_all_max.update_layout(
    title="",
    xaxis_title="Param√®tre",
    yaxis_title="r¬≤ (AROME - Stations)",
    yaxis=dict(range=[0, 1])
)

# Appliquer le template
fig_r2_all_max.update_layout(template="simple_white")

# Sauvegarde et affichage dans un iframe
scatter_path = f"assets/hist_r2_jour_model_min_AIC.html"
pio.write_html(fig_r2_all_max, file=scatter_path, include_plotlyjs="cdn", full_html=False)

html_scatter = f"""
<div style="height: 500px; border: 1px solid #ccc; border-radius: 6px; display: flex; align-items: center; justify-content: center; overflow: hidden; margin-top: 10px;">
    <iframe loading="lazy" src="{scatter_path}" width="100%" height="100%" frameborder="0" style="flex: 3; width: 0; min-width: 0; max-width: 100%;"></iframe>
</div>
"""
```

::: {.column width="50%"}
```{python}
display(HTML(html_scatter))
```
:::
:::



---


# Changement du niveau de retour

$$
\Delta q^{T}_{X\,\text{ans}} = \frac{X}{\Delta a} \left[\, \mu_1 + \frac{\sigma_1}{\xi}\,z_T \,\right]
$$

o√π¬†:

* $\Delta a$ = dur√©e totale du mod√®le (en ann√©es), par exemple 40 si de 1980 √† 2020
* $X$ = nombre d'ann√©es consid√©r√©es pour la variation (ex‚ÄØ: 10 pour un changement par 10 ans)
* $\mu_1$, $\sigma_1$, $\xi$ = param√®tres du mod√®le GEV non stationnaire (issus de l‚Äôajustement)
* $z_T$ = terme d√©pendant de la p√©riode de retour $T$

$$
z_T = 
\begin{cases}
\displaystyle
\left[ -\log\left(1 - \frac{1}{T}\right) \right]^{-\xi} - 1 & \text{si } \xi \neq 0 \\\\
\displaystyle
\log \left( -\log\left(1 - \frac{1}{T}\right) \right) & \text{si } \xi = 0 \ (\text{cas Gumbel})
\end{cases}
$$


```{python}
T_choice=10 # P√©riode de retour
par_X_annees=10
year_display_min = config["years"]["min"]
year_display_max = config["years"]["max"]


def carte_retour(model_name, echelle, season_choice, half):
    MODEL_PARAM, MODEL_NAME = menu_config_gev()
    MODEL_TITLE = {v: k for k, v in MODEL_NAME.items()}

    model_title = MODEL_TITLE.get(model_name, model_name)

    title = f"Changement du niveau de retour {T_choice} ans par {par_X_annees} ans" #du mod√®le {model_title}
    result_gev = pipeline_data_gev_quarto(
        config=config,
        model_name=model_name,
        echelle=echelle,
        season_choice=season_choice,
        T_choice=T_choice,
        par_X_annees=par_X_annees,
        min_year=year_display_min,
        max_year=year_display_max
    )
    # Ex√©cution pipeline pour la moiti√© choisie
    html_map, _, r2, me, n, percent = pipeline_quarto_gev_half_france(
        model_name=model_name,
        season_choice=season_choice,
        echelle=echelle,
        par_X_annees=par_X_annees,
        result=result_gev,
        half=half,
        height=600
    )
    pipeline_total_title_map_legend_scatter_delta(
        title=title,
        year_min=config["years"]["min"],
        year_max=config["years"]["max"],
        echelle=echelle,
        season_choice=season_choice,
        html_map_legend=html_map,
        html_scatter=None
    )
    return result_gev
```

---

```{python}
model_name="niveau_retour"
echelle="quotidien"
season_choice = "son"
half = "sud"  # ou "nord"
carte_retour(model_name, echelle, season_choice, half)
```

---

-->

```{python}
from typing import Sequence, Mapping, Tuple
from pathlib import Path

import polars as pl
import geopandas as gpd
from shapely.geometry import box
import matplotlib.pyplot as plt
from matplotlib.colors import ListedColormap, BoundaryNorm, TwoSlopeNorm, Normalize, LinearSegmentedColormap

from __future__ import annotations

from pathlib import Path
from typing import Mapping, Optional, Sequence, Tuple

import geopandas as gpd
import matplotlib as mpl
import matplotlib.pyplot as plt
import numpy as np
import polars as pl
from matplotlib.colors import BoundaryNorm, LinearSegmentedColormap, TwoSlopeNorm
from shapely.geometry import box


def plot_four_polars_grids(
    datasets: Sequence[Mapping[str, pl.DataFrame]],
    *,
    echelle: str,
    titles: Sequence[str] | None = None,  # ex: ['SON', 'DJF', 'MAM', 'JJA']
    lat_col: str = "lat",
    lon_col: str = "lon",
    val_col: str = "ERROR",
    # Observations
    obs_key: str = "observed_show",
    show_obs: bool = True,  # n'influence plus que l'affichage
    min_pt: int=2,
    max_pt: int=11,
    obs_edgecolor: str = "#000000",
    obs_facecolor: Optional[str] = None,
    # Grid
    side_km: float = 2.5,
    # Colormap
    cmap_bool: Tuple[str, str] = ("#f0f0f0", "#d73027"),
    # Relief
    relief_path: str = "data/external/niveaux/selection_courbes_niveau_france.shp",
    relief_linewidth: float = 0.3,
    relief_color: str = "#666666",
    figsize: Tuple[int, int] = (6, 6),
    show_mod: bool = True,
    show_signif: bool = False,  # filtre significatif sur obs
    numero: int=1,
    saturation_val: int=99.5
):
    """Trace quatre cartes polaires + une l√©gende commune (SVG).

    La plage de la l√©gende est calcul√©e sur **l'ensemble** des valeurs (mod√®le
    et observations), que l'on choisisse ou non de les afficher.
    """

    # ------------------------------------------------------------------
    # Pr√©paration des GeoDataFrames
    # ------------------------------------------------------------------
    model_gdfs, obs_gdfs = [], []
    for d in datasets:
        # -- Mod√®le
        df_m = d.get("modelised_show")
        if df_m is None:
            model_gdfs.append(None)


        else:
            if not isinstance(df_m, pl.DataFrame):
                raise TypeError("'modelised_show' doit √™tre un pl.DataFrame.")
            gdf_m = gpd.GeoDataFrame(
                df_m.to_pandas(),  # Convertissez df_m en DataFrame pandas
                geometry=gpd.points_from_xy(df_m[lon_col].to_list(), df_m[lat_col].to_list()),
                crs="EPSG:4326",
            ).to_crs("EPSG:2154")
            model_gdfs.append(gdf_m)  # Ajoutez gdf_m √† model_gdfs

        # -- Observations (toujours charg√©es pour la l√©gende)
        if obs_key in d:
            df_o = d[obs_key]
            if not isinstance(df_o, pl.DataFrame):
                raise TypeError("'observed_show' doit √™tre un pl.DataFrame.")
            if "significant" in df_o.columns and show_signif:
                df_o = df_o.filter(pl.col("significant"))
            obs_gdfs.append(
                gpd.GeoDataFrame(
                    df_o.to_pandas(),
                    geometry=gpd.points_from_xy(df_o[lon_col].to_list(), df_o[lat_col].to_list()),
                    crs="EPSG:4326",
                ).to_crs("EPSG:2154")
                if df_o.height > 0
                else None
            )
        else:
            obs_gdfs.append(None)

    # Titres par d√©faut
    if titles is None:
        titles = [str(i) for i in range(1, len(model_gdfs) + 1)]

    # ------------------------------------------------------------------
    # Grille carr√©e autour des points mod√©lis√©s
    # ------------------------------------------------------------------
    half = side_km * 500  # m
    for gdf in model_gdfs:
        gdf["geometry"] = gdf.geometry.apply(
            lambda p: box(p.x - half, p.y - half, p.x + half, p.y + half)
        )

    # ------------------------------------------------------------------
    # Masque France m√©tropolitaine
    # ------------------------------------------------------------------
    deps = (
        gpd.read_file("https://france-geojson.gregoiredavid.fr/repo/departements.geojson")
        .to_crs("EPSG:2154")
    )
    deps_metro = deps[~deps["code"].isin(["2A", "2B"])]
    deps_metro["geometry"] = deps_metro.geometry.simplify(500)
    mask = deps_metro.union_all()

    model_gdfs = [gpd.overlay(g, deps_metro[["geometry"]], how="intersection") for g in model_gdfs]
    obs_gdfs = [g.clip(mask) if isinstance(g, gpd.GeoDataFrame) else None for g in obs_gdfs]

    # ------------------------------------------------------------------
    # Relief
    # ------------------------------------------------------------------
    relief = gpd.read_file(Path(relief_path).resolve()).to_crs("EPSG:2154").clip(mask)

    # ------------------------------------------------------------------
    # Saturation des valeurs extr√™mes (1 % sup.)
    # ------------------------------------------------------------------

    # 1) Avant la saturation, m√©moriser la valeur originale
    for gdf in model_gdfs + [g for g in obs_gdfs if g is not None]:
        gdf["_val_raw"] = gdf[val_col].copy()         # ‚Üê copie intacte

    all_values: list[float] = []
    for gdf in model_gdfs:
        all_values.extend(gdf[val_col].to_numpy())
    for gdf in obs_gdfs:
        if gdf is not None:
            all_values.extend(gdf[val_col].to_numpy())

    is_bool = model_gdfs[0][val_col].dtype == bool
    if all_values and not is_bool:
        seuil = np.percentile(np.abs(all_values), saturation_val)
        for gdf in model_gdfs + [g for g in obs_gdfs if g is not None]:
            gdf[val_col] = np.where(np.abs(gdf[val_col]) > seuil,
                                    np.sign(gdf[val_col]) * seuil,
                                    gdf[val_col])

    # ------------------------------------------------------------------
    # Colormap & Norm communes
    # ------------------------------------------------------------------
    if is_bool:
        cmap = mpl.colors.ListedColormap(list(cmap_bool))
        norm = BoundaryNorm([-0.5, 0.5, 1.5], ncolors=2)
        for g in model_gdfs + [g for g in obs_gdfs if g is not None]:
            g["_val_int"] = g[val_col].astype(int)
        col = "_val_int"
    else:
        vmin = float(min([g[val_col].min() for g in model_gdfs] + [g[val_col].min() for g in obs_gdfs if g is not None]))
        vmax = float(max([g[val_col].max() for g in model_gdfs] + [g[val_col].max() for g in obs_gdfs if g is not None]))
        vcenter = 0 if vmin < 0 < vmax else (vmin + vmax) / 2
        norm = TwoSlopeNorm(vmin=vmin, vcenter=vcenter, vmax=vmax)
        cmap = LinearSegmentedColormap.from_list("bwr_custom", ["red", "#ffffff", "blue"], N=100)
        col = val_col

    # ------------------------------------------------------------------
    # Export cartes
    # ------------------------------------------------------------------
    Path("presentation_files/map").mkdir(parents=True, exist_ok=True)
    modes = {"rast": 0, "norast": 1}

    for title, gdf_m, gdf_o in zip(titles, model_gdfs, obs_gdfs):
        for mode, z in modes.items():
            fig, ax = plt.subplots(figsize=figsize)

            deps_metro.boundary.plot(ax=ax, edgecolor="#AAAAAA", linewidth=0.2, zorder=0)

            if show_mod:
                gdf_m.plot(ax=ax, column=col, cmap=cmap, norm=norm, linewidth=0, zorder=1)

            if show_obs and gdf_o is not None and not gdf_o.empty:

                # ------------------------------------------------------------------
                # √âchelle des diam√®tres de points
                # ------------------------------------------------------------------
                abs_vals = gdf_o["_val_raw"].abs()
                abs_max  = abs_vals.max()
                gdf_o["_size_pt2"] = ((abs_vals / abs_max) * (max_pt - min_pt) + min_pt) ** 2

                kw = dict(
                    markersize="_size_pt2",
                    marker="o",
                    edgecolor=obs_edgecolor,
                    linewidth=0.1,
                    zorder=3,
                )

                if obs_facecolor is None:
                    gdf_o.plot(ax=ax, column=col, cmap=cmap, norm=norm, **kw)
                else:
                    gdf_o.plot(ax=ax, facecolor=obs_facecolor, **kw)

            relief.plot(ax=ax, color=relief_color, linewidth=relief_linewidth, alpha=0.8, zorder=2)

            ax.set_axis_off()
            ax.set_rasterization_zorder(z)

            if mode == "rast":
                sm = mpl.cm.ScalarMappable(cmap=cmap, norm=norm)
                sm.set_array([])
                cbar = fig.colorbar(sm, ax=ax, shrink=0.6, aspect=20)
                if is_bool:
                    cbar.set_ticks([0, 1])
                    cbar.set_ticklabels(["Non", "Oui"])

            suffix_obs = "_obs" if show_obs else ""
            suffix_mod = "_mod" if show_mod else ""
            suffix_signif = "_signif" if show_signif else ""
            name = f"{echelle}_{title}_{mode}{suffix_mod}{suffix_obs}{suffix_signif}"

            fig.savefig(f"presentation_files/map/{name}.svg", format="svg", bbox_inches="tight", pad_inches=0)
            plt.close(fig)

    # ------------------------------------------------------------------
    # L√©gende seule
    # ------------------------------------------------------------------
    mpl.rcParams.update({'font.size': 16})
    fig2 = plt.figure(figsize=(1, figsize[1]*2))
    ax2 = fig2.add_axes([0.25, 0.05, 0.5, 0.9])
    sm2 = mpl.cm.ScalarMappable(cmap=cmap, norm=norm)
    sm2.set_array([])
    cb2 = fig2.colorbar(sm2, cax=ax2)
    if is_bool:
        cb2.set_ticks([0, 1])
        cb2.set_ticklabels(["Non", "Oui"])

    fig2.savefig(f"presentation_files/map/{echelle}_legend_{numero}.svg", format="svg", bbox_inches="tight", pad_inches=0)
    plt.close(fig2)

```


```{python}
echelles = ["quotidien"] #, "horaire"
seasons  = ["son", "djf", "mam", "jja"]
datasets = {e: [] for e in echelles}

for e in echelles:
    for s in seasons:
        res = pipeline_data_gev_quarto(
            config=config,
            model_name="niveau_retour",
            echelle=e,
            season_choice=s,
            T_choice=10,
            par_X_annees=10,
            min_year=config["years"]["min"],
            max_year=config["years"]["max"],
        )
        datasets[e].append(res)    # On range le r√©sultat dans la bonne liste

for show in [True, False]:
    for e in echelles:
        plot_four_polars_grids(
            datasets[e],
            echelle=e,
            val_col="z_T_p",          # nom de la colonne √† colorer / symboliser
            titles=[s.upper() for s in seasons],  # titres des 4 sous-cartes
            show_mod=show,
            show_obs=not show
        )
```

---

```{python}
title_show = pipeline_title("Tendances relatives (%) du niveau de retour 10 ans estim√©e par le meilleur mod√®le", 1985, 2022, "quotidien", None)
display(HTML(title_show))
```



<style>
  /* Reset complet de la grille */
  table.no-gutter {
    border-collapse: collapse;   /* fusionne bordures */
    border-spacing: 0;           /* espacement nul */
    margin: 0;
    padding: 0;
  }
  table.no-gutter th,
  table.no-gutter td {
    border: none;                /* pas de lignes */
    margin: 0;
    padding: 0;                  /* pas de marge interne */
  }
  table.no-gutter th {
    text-align: center;
  }
  table.no-gutter img {
    display: block;              /* pas d‚Äôespace bas */
    margin: 0;
    padding: 0;
    width: 300px;                /* ajustez selon besoin */
    height: 300px;
  }
</style>



<table class="no-gutter" border="0" cellspacing="0" cellpadding="0" style="width:100%; text-align:center;">
  <thead>
    <tr>
      <th>SON</th>
      <th>DJF</th>
      <th>MAM</th>
      <th>JJA</th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
        <td>
        <a href="presentation_files/map/quotidien_SON_rast_mod.svg" target="_blank" rel="noopener">
            <img src="presentation_files/map/quotidien_SON_norast_mod.svg" alt="SON">
        </a>
        </td>
        <td>
        <a href="presentation_files/map/quotidien_DJF_rast_mod.svg" target="_blank" rel="noopener">
            <img src="presentation_files/map/quotidien_DJF_norast_mod.svg" alt="DJF">
        </a>
        </td>
        <td>
        <a href="presentation_files/map/quotidien_MAM_rast_mod.svg" target="_blank" rel="noopener">
            <img src="presentation_files/map/quotidien_MAM_norast_mod.svg" alt="MAM">
        </a>
        </td>
        <td>
        <a href="presentation_files/map/quotidien_JJA_rast_mod.svg" target="_blank" rel="noopener">
            <img src="presentation_files/map/quotidien_JJA_norast_mod.svg" alt="JJA">
        </a>
        </td>
    <td rowspan="2" style="vertical-align: middle; text-align: center;">
    <object type="image/svg+xml" data="presentation_files/map/quotidien_legend_1.svg"
            width="40" height="600" class="legend-svg">
    </object>
    </td>
    </tr>
    <tr>
      <td>
        <a href="presentation_files/map/quotidien_SON_rast_obs.svg" target="_blank" rel="noopener">
          <img src="presentation_files/map/quotidien_SON_norast_obs.svg" alt="SON">
        </a>
      </td>
      <td>
        <a href="presentation_files/map/quotidien_DJF_rast_obs.svg" target="_blank" rel="noopener">
          <img src="presentation_files/map/quotidien_DJF_norast_obs.svg" alt="DJF">
        </a>
      </td>
      <td>
        <a href="presentation_files/map/quotidien_MAM_rast_obs.svg" target="_blank" rel="noopener">
          <img src="presentation_files/map/quotidien_MAM_norast_obs.svg" alt="MAM">
        </a>
      </td>
      <td>
        <a href="presentation_files/map/quotidien_JJA_rast_obs.svg" target="_blank" rel="noopener">
          <img src="presentation_files/map/quotidien_JJA_norast_obs.svg" alt="JJA">
        </a>
      </td>
    </tr>
  </tbody>
</table>


---

```{python}
echelles = ["quotidien"] #, "horaire"
seasons  = ["son_bis", "nod", "s", "o", "n", "d"]
datasets = {e: [] for e in echelles}

for e in echelles:
    for s in seasons:
        res = pipeline_data_gev_quarto(
            config=config,
            model_name="niveau_retour",
            echelle=e,
            season_choice=s if s != "son_bis" else "son",
            T_choice=10,
            par_X_annees=10,
            min_year=config["years"]["min"],
            max_year=config["years"]["max"],
        )
        datasets[e].append(res)    # On range le r√©sultat dans la bonne liste

for e in echelles:
    plot_four_polars_grids(
        datasets[e],
        echelle=e,
        val_col="z_T_p",          # nom de la colonne √† colorer / symboliser
        titles=[s.upper() for s in seasons],  # titres des 4 sous-cartes
        show_mod=False,
        show_obs=True,
        numero=2,
        saturation_val=99
    )
```


```{python}
title_show = pipeline_title("Tendances relatives (%) du niveau de retour 10 ans estim√©e par le meilleur mod√®le", 1985, 2022, "quotidien", None)
display(HTML(title_show))
```

<style>
figure { margin: 0; text-align: center; }
figcaption { margin-top: .3rem; font-size: .9rem; }
</style>



<table class="no-gutter" border="0" cellspacing="0" cellpadding="0" style="width:100%; text-align:center;">
  <thead>
    <tr>
      <th></th>
      <th>SON</th>
      <th>OND</th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
        <td>
        </td>
        <td>
        <a href="presentation_files/map/quotidien_SON_BIS_rast_obs.svg" target="_blank" rel="noopener">
            <img src="presentation_files/map/quotidien_SON_BIS_norast_obs.svg" alt="SON">
        </a>
        </td>
        <td>
        <a href="presentation_files/map/quotidien_NOD_rast_obs.svg" target="_blank" rel="noopener">
            <img src="presentation_files/map/quotidien_NOD_norast_obs.svg" alt="DJF">
        </a>
        </td>
        <td>
        </td>
    <td rowspan="2" style="vertical-align: middle; text-align: center;">
    <object type="image/svg+xml" data="presentation_files/map/quotidien_legend_2.svg"
            width="40" height="600" class="legend-svg">
    </object>
    </td>
    </tr>
  <tr>
    <td>
      <figure>
        <a href="presentation_files/map/quotidien_S_rast_obs.svg" target="_blank" rel="noopener">
          <img src="presentation_files/map/quotidien_S_norast_obs.svg" alt="September">
        </a>
        <figcaption>Sept</figcaption>
      </figure>
    </td>
    <td>
      <figure>
        <a href="presentation_files/map/quotidien_O_rast_obs.svg" target="_blank" rel="noopener">
          <img src="presentation_files/map/quotidien_O_norast_obs.svg" alt="October">
        </a>
        <figcaption>Oct</figcaption>
      </figure>
    </td>
    <td>
      <figure>
        <a href="presentation_files/map/quotidien_N_rast_obs.svg" target="_blank" rel="noopener">
          <img src="presentation_files/map/quotidien_N_norast_obs.svg" alt="November">
        </a>
        <figcaption>Nov</figcaption>
      </figure>
    </td>
    <td>
      <figure>
        <a href="presentation_files/map/quotidien_D_rast_obs.svg" target="_blank" rel="noopener">
          <img src="presentation_files/map/quotidien_D_norast_obs.svg" alt="December">
        </a>
        <figcaption>Dec</figcaption>
      </figure>
    </td>
  </tr>
</tbody>
</table>

# La suite...

<br/><br/><br/>

<h2>Journalier (v√©rification mod√©lisation statistique) *vs.* horaire (objectif initial)</h2><br/> 
<h2>Saison *vs.* mois</h2><br/> 
<h2>Significativit√© ?</h2><br/> 

<br/><br/>

--- 

<div class="fin">Merci.</div>