---
title: "Avancement du stage"
author: Decoopman Nicolas
format:
  revealjs:
    theme: simple
    slide-number: true
    pdf-separate-fragments: false
    toc: false
    width: 1280
    height: 720
    self-contained: false 
    allow-scripts: true 
    css: presentation/styles.css
execute:
  cache: true
  echo: false
  warning: false
  message: false
  error: true
freeze: auto  
jupyter: stage
---

```{python}
# import shutil
# shutil.rmtree("__quarto_cache", ignore_errors=True)

# Imports
import yaml
from pathlib import Path

import pandas as pd
import polars as pl
import numpy as np

import plotly.express as px
from IPython.display import display, HTML
import plotly.io as pio

from app.utils.data_utils import (
    match_and_compare,
    add_metadata,
    dont_show_extreme,
    standardize_year,
    filter_nan
)

from app.utils.stats_utils import (
    generate_metrics
)

from app.utils.gev_utils import safe_compute_return
from app.pipelines.pipeline_quarto import *

# Charger les paramètres depuis config.yaml
config_path = Path("app/config/config.yaml")
with open(config_path, "r") as f:
    config = yaml.safe_load(f)
```


## Précipitations extrêmes horaires en France

<br><br>

### 1. Objectif
Analyser les tendances des précipitations extrêmes horaires en France (1959–2022) à partir du modèle CP-RCM CNRM-AROME (2.5 km) forcé par ERA5
<br>

### 2. Méthodes

- GEV stationnaire et non stationnaire
- Comparaison avec observations Météo-France (+ EDF ?)
<br>

### 3. Enjeux

- Effet du réchauffement climatique sur les extrêmes
- Zones à forte variabilité (Alpes, Méditerranée)
- Contribution à la connaissance du risque hydrométéo


# AROME vs. stations

Nombre de jours de pluie

```{python}
title="Nombre de jour de pluie moyen"
``` 

---

```{python}
year_display_min = config["years"]["min"]
year_display_max = config["years"]["max"]
echelle="quotidien"

# Étape 1 : récupérer résultats avec pipeline_data_quarto
result = pipeline_data_quarto(
    config=config,
    stat_choice="numday",
    echelle=echelle,
    min_year=year_display_min,
    max_year=year_display_max,
    season_choice="hydro",
    unit_choice="jours",
    missing_choice=0.15,
    quantile_choice=0.995
)
# Étape 2 : affichage carte + scatter
html_map_legend, html_scatter, r2, me, n, percent = pipeline_map_legend_scatter(
    name="jour_pluie_total",
    result=result,
    echelle=echelle,
    stat_choice_label=title,
    unit_choice="jours"
)


display(HTML(f"""
    <div style="font-size: 18px; color: #333;">
        <p style="font-size: 22px; font-weight: bold; color: #2c3e50;">{title}</p>
        <p style="font-size: 18px; color: #3498db;">
            de <span style="font-weight: bold; color: #e74c3c;">{year_display_min}</span> à <span style="font-weight: bold; color: #e74c3c;">{year_display_max}</span> 
            (Saison : <span style="font-weight: bold; color: #f39c12;">année hydrologique</span> | Echelle : <span style="font-weight: bold; color: #f39c12;">{echelle}</span>)
        </p> 
    </div>

"""))
```


::: {.columns style="display: flex; gap: 0px; margin: 0;"}
::: {.column width="50%"}
```{python}
display(HTML(html_map_legend))
```
:::
::: {.column width="50%"}
```{python}
display(HTML(html_scatter))
```
:::
:::

```{python}
display(HTML(f"Δ (AROME - Stations) : {me:+.1f} jours ({percent*100:+.1f}%)"))
```

- tendance à déclencher des jours de pluie plus fréquemment que ce qui est observé  
- trop sensible au seuil de 1 mm/j qui serait à augmenter ?

---



```{python}
year_display_min = 2000
year_display_max = config["years"]["max"]
echelle="quotidien"

# Étape 1 : récupérer les résultats avec pipeline_data_quarto
result = pipeline_data_quarto(
    config=config,
    stat_choice="numday",
    echelle=echelle,
    min_year=year_display_min,
    max_year=year_display_max,
    season_choice="hydro",
    unit_choice="jours",
    missing_choice=0.15,
    quantile_choice=0.995
)

me_prev = me
# Étape 2 : affichage carte + scatter
html_map_legend, html_scatter, r2, me, n, percent = pipeline_map_legend_scatter(
    name="jour_pluie_2000",
    result=result,
    echelle=echelle,
    stat_choice_label="Jour de pluie",
    unit_choice="jours"
)

display(HTML(f"""
    <div style="font-size: 18px; color: #333;">
        <p style="font-size: 22px; font-weight: bold; color: #2c3e50;">{title}</p>
        <p style="font-size: 18px; color: #3498db;">
            de <span style="font-weight: bold; color: #e74c3c;">{year_display_min}</span> à <span style="font-weight: bold; color: #e74c3c;">{year_display_max}</span> 
            (Saison : <span style="font-weight: bold; color: #f39c12;">année hydrologique</span> | Echelle : <span style="font-weight: bold; color: #f39c12;">{echelle}</span>)
        </p> 
    </div>
"""))
```

::: {.columns style="display: flex; gap: 0px; margin: 0;"}
::: {.column width="50%"}
```{python}
display(HTML(html_map_legend))
```
:::
::: {.column width="50%"}
```{python}
display(HTML(html_scatter))
```
:::
:::

```{python}
display(HTML(f"Δ (AROME - Stations) : {me:+.1f} jours ({percent*100:+.1f}%)"))
```


# AROME vs. stations

Cumul des précipitations

```{python}
title="Moyenne des précipitations"
``` 

---

```{python}
year_display_min = config["years"]["min"]
year_display_max = config["years"]["max"]
echelle="quotidien"

# Étape 1 : récupérer les résultats avec pipeline_data_quarto
result = pipeline_data_quarto(
    config=config,
    stat_choice="mean",
    echelle=echelle,
    min_year=year_display_min,
    max_year=year_display_max,
    season_choice="hydro",
    missing_choice=0.15,
    quantile_choice=0.995
)

# Étape 2 : affichage carte + scatter
html_map_legend, html_scatter, r2, me_1959, n, percent_1959 = pipeline_map_legend_scatter(
    name="jour_mean_total",
    result=result,
    echelle=echelle,
    stat_choice_label="Moyenne des précipitations"
)

display(HTML(f"""
    <div style="font-size: 18px; color: #333;">
        <p style="font-size: 22px; font-weight: bold; color: #2c3e50;">{title}</p>
        <p style="font-size: 18px; color: #3498db;">
            de <span style="font-weight: bold; color: #e74c3c;">{year_display_min}</span> à <span style="font-weight: bold; color: #e74c3c;">{year_display_max}</span> 
            (Saison : <span style="font-weight: bold; color: #f39c12;">année hydrologique</span> | Echelle : <span style="font-weight: bold; color: #f39c12;">{echelle}</span>)
        </p> 
    </div>
"""))
```



::: {.columns style="display: flex; gap: 0px; margin: 0;"}
::: {.column width="50%"}
```{python}
display(HTML(html_map_legend))
```
:::
::: {.column width="50%"}
```{python}
display(HTML(html_scatter))
```
:::
:::

```{python}
year_display_min = 2000
year_display_max = config["years"]["max"]
echelle="quotidien"

# Étape 1 : récupérer les résultats avec pipeline_data_quarto
result = pipeline_data_quarto(
    config=config,
    stat_choice="mean",
    echelle=echelle,
    min_year=year_display_min,
    max_year=year_display_max,
    season_choice="hydro",
    missing_choice=0.15,
    quantile_choice=0.995
)

# Étape 2 : affichage carte + scatter
_, _, _, me_2000, _, percent_2000 = pipeline_map_legend_scatter(
    name="jour_mean_2000",
    result=result,
    echelle=echelle,
    stat_choice_label="Moyenne des précipitations"
)
```


```{python}
display(HTML(f"Δ (AROME - Stations) de {config["years"]["min"]} à {year_display_max} : {me_1959:+.3f} mm/j ({percent_1959*100:+.1f}%)"))
display(HTML(f"Δ (AROME - Stations) de {year_display_min} à {year_display_max} : {me_2000:+.3f} mm/j ({percent_2000*100:+.1f}%)"))
```

- Répartition correcte de la quantité totale d’eau 

---

```{python}
year_display_min = 2000
year_display_max = config["years"]["max"]
echelle="horaire"

# Étape 1 : récupérer les résultats avec pipeline_data_quarto
result = pipeline_data_quarto(
    config=config,
    stat_choice="mean",
    echelle=echelle,
    min_year=year_display_min,
    max_year=year_display_max,
    season_choice="hydro",
    missing_choice=0.15,
    quantile_choice=0.995
)

# Étape 2 : affichage carte + scatter
html_map_legend, html_scatter, r2, me, n, percent = pipeline_map_legend_scatter(
    name="horaire_mean_2000",
    result=result,
    echelle=echelle,
    stat_choice_label="Moyenne des précipitations"
)

display(HTML(f"""
    <div style="font-size: 18px; color: #333;">
        <p style="font-size: 22px; font-weight: bold; color: #2c3e50;">{title}</p>
        <p style="font-size: 18px; color: #3498db;">
            de <span style="font-weight: bold; color: #e74c3c;">{year_display_min}</span> à <span style="font-weight: bold; color: #e74c3c;">{year_display_max}</span> 
            (Saison : <span style="font-weight: bold; color: #f39c12;">année hydrologique</span> | Echelle : <span style="font-weight: bold; color: #f39c12;">{echelle}</span>)
        </p> 
    </div>
"""))
```


::: {.columns style="display: flex; gap: 0px; margin: 0;"}
::: {.column width="50%"}
```{python}
display(HTML(html_map_legend))
```
:::
::: {.column width="50%"}
```{python}
display(HTML(html_scatter))
```
:::
:::

```{python}
display(HTML(f"Δ (AROME - Stations) : {me:+.3f} mm/h ({percent*100:+.1f}%)"))
```

- Résultat semblable

# Conclusion : avec AROME il y a des pluies...


- **plus fréquentes**... surestime le nombre de jours de pluie  
- **en plus faible quantité**... mais pas le cumul

# Précipitations extrêmes

Evaluation des structures spatiales via les valeurs moyennées sur la période

```{python}
title="Moyenne des maxima des précipitations"
``` 

---

```{python}
year_display_min = config["years"]["min"]
year_display_max = config["years"]["max"]
echelle="quotidien"

# Étape 1 : récupérer les résultats avec pipeline_data_quarto
result = pipeline_data_quarto(
    config=config,
    stat_choice="mean-max",
    echelle=echelle,
    min_year=year_display_min,
    max_year=year_display_max,
    season_choice="hydro",
    missing_choice=0.15,
    quantile_choice=0.995
)

# Étape 2 : affichage carte + scatter
html_map_legend, html_scatter, r2, me_1959, n, percent_1959 = pipeline_map_legend_scatter(
    name="jour_mean_max_total",
    result=result,
    echelle=echelle,
    stat_choice_label="Moyenne des maxima"
)

display(HTML(f"""
    <div style="font-size: 18px; color: #333;">
        <p style="font-size: 22px; font-weight: bold; color: #2c3e50;">{title}</p>
        <p style="font-size: 18px; color: #3498db;">
            de <span style="font-weight: bold; color: #e74c3c;">{year_display_min}</span> à <span style="font-weight: bold; color: #e74c3c;">{year_display_max}</span> 
            (Saison : <span style="font-weight: bold; color: #f39c12;">année hydrologique</span> | Echelle : <span style="font-weight: bold; color: #f39c12;">{echelle}</span>)
        </p> 
    </div>
"""))
```


::: {.columns style="display: flex; gap: 0px; margin: 0;"}
::: {.column width="50%"}
```{python}
display(HTML(html_map_legend))
```
:::
::: {.column width="50%"}
```{python}
display(HTML(html_scatter))
```
:::
:::

```{python}
year_display_min = 2000
year_display_max = config["years"]["max"]
echelle="quotidien"

# Étape 1 : récupérer les résultats avec pipeline_data_quarto
result = pipeline_data_quarto(
    config=config,
    stat_choice="mean-max",
    echelle=echelle,
    min_year=year_display_min,
    max_year=year_display_max,
    season_choice="hydro",
    missing_choice=0.15,
    quantile_choice=0.995
)

# Étape 2 : affichage carte + scatter
_, _, _, me_2000, _, percent_2000 = pipeline_map_legend_scatter(
    name="jour_mean_max_2000",
    result=result,
    echelle=echelle,
    stat_choice_label="Moyenne des maxima"
)

display(HTML(f"Δ (AROME - Stations) de {config["years"]["min"]} à {year_display_max} : {me_1959:+.3f} mm/j ({percent_1959*100:+.1f}%)"))
display(HTML(f"Δ (AROME - Stations) de {year_display_min} à {year_display_max} : {me_2000:+.3f} mm/j ({percent_2000*100:+.1f}%)"))
```

- Estimation bruitée sur une période restreinte ?

---

```{python}
year_display_min = 2000
year_display_max = config["years"]["max"]
echelle="horaire"

# Étape 1 : récupérer les résultats avec pipeline_data_quarto
result = pipeline_data_quarto(
    config=config,
    stat_choice="mean-max",
    echelle=echelle,
    min_year=year_display_min,
    max_year=year_display_max,
    season_choice="hydro",
    missing_choice=0.15,
    quantile_choice=0.995
)

# Étape 2 : affichage carte + scatter
html_map_legend, html_scatter, r2, me, n, percent = pipeline_map_legend_scatter(
    name="horaire_mean_max_2000",
    result=result,
    echelle=echelle,
    stat_choice_label="Moyenne des maxima"
)

display(HTML(f"""
    <div style="font-size: 18px; color: #333;">
        <p style="font-size: 22px; font-weight: bold; color: #2c3e50;">{title}</p>
        <p style="font-size: 18px; color: #3498db;">
            de <span style="font-weight: bold; color: #e74c3c;">{year_display_min}</span> à <span style="font-weight: bold; color: #e74c3c;">{year_display_max}</span> 
            (Saison : <span style="font-weight: bold; color: #f39c12;">année hydrologique</span> | Echelle : <span style="font-weight: bold; color: #f39c12;">{echelle}</span>)
        </p> 
    </div>    
"""))
```


::: {.columns style="display: flex; gap: 0px; margin: 0;"}
::: {.column width="50%"}
```{python}
display(HTML(html_map_legend))
```
:::
::: {.column width="50%"}
```{python}
display(HTML(html_scatter))
```
:::
:::

```{python}
display(HTML(f"Δ (AROME - Stations) : {me:+.3f} mm/h ({percent*100:+.1f}%)"))
```

- Rappel : le cumul était bon donc les orages horaires les plus forts ont une faible emprise spatiale ?
- Oui : le regroupement de stations sur une même grille réduit le Δ


---

```{python}
# Nouvelle version qui utilise directement le nom du quadrant
def afficher_quadrant_par_nom(result, config, quadrant_name, quadrants, echelle="horaire", stat_label="Moyenne des maxima"):
    year_display_min = 2000
    year_display_max = config["years"]["max"]

    # Extraire les bornes géographiques du quadrant
    bounds = quadrants.get(quadrant_name.upper())
    if bounds is None:
        raise ValueError(f"Quadrant '{quadrant_name}' non reconnu. Choisir parmi {list(quadrants.keys())}")

    lat_min = bounds["lat_min"]
    lat_max = bounds["lat_max"]
    lon_min = bounds["lon_min"]
    lon_max = bounds["lon_max"]

    # Filtrage des données
    result_filtered = {}
    for key, value in result.items():
        if isinstance(value, pl.DataFrame):
            result_filtered[key] = value.filter(
                (value["lat"] >= lat_min) & (value["lat"] < lat_max) &
                (value["lon"] >= lon_min) & (value["lon"] < lon_max)
            )
        elif isinstance(value, pd.DataFrame):
            result_filtered[key] = value[
                (value["lat"] >= lat_min) & (value["lat"] < lat_max) &
                (value["lon"] >= lon_min) & (value["lon"] < lon_max)
            ]
        else:
            result_filtered[key] = value

    # Génération de la carte et du scatter
    html_map_legend, html_scatter, r2, me, n, percent = pipeline_map_legend_scatter(
        name=f"{echelle}_mean_max_{year_display_min}_{quadrant_name}",
        result=result_filtered,
        echelle=echelle,
        stat_choice_label=stat_label,
    )

    # Affichage HTML
    display(HTML(f"""
        <div style="font-size: 18px; color: #333;">
            <p style="font-size: 22px; font-weight: bold; color: #2c3e50;">{title} {quadrant_name.upper()}</p>
            <p style="font-size: 18px; color: #3498db;">
                de <span style="font-weight: bold; color: #e74c3c;">{year_display_min}</span> à 
                <span style="font-weight: bold; color: #e74c3c;">{year_display_max}</span> 
                (Saison : <span style="font-weight: bold; color: #f39c12;">année hydrologique</span> | 
                Échelle : <span style="font-weight: bold; color: #f39c12;">{echelle}</span>)
            </p> 
        </div>    
    """))

    display(HTML(f"""
    <div class="columns" style="display: flex; gap: 0px; margin: 0;">
        <div class="column" style="width: 50%;">{html_map_legend}</div>
        <div class="column" style="width: 50%;">{html_scatter}</div>
    </div>
    """))

    display(HTML(f"Δ (AROME - Stations) : {me:+.3f} mm/h ({percent*100:+.1f}%)"))



# Définitions approximatives pour chaque quadrant
quadrants = {
    "SE": {"lat_min": 42, "lat_max": 46.5, "lon_min": 2.5, "lon_max": 7.9},
    "NE": {"lat_min": 46, "lat_max": 51.5, "lon_min": 2.5, "lon_max": 10},
    "SO": {"lat_min": 42, "lat_max": 46.5, "lon_min": -5.0, "lon_max": 2.5},
    "NO": {"lat_min": 46.5, "lat_max": 51.5, "lon_min": -5.0, "lon_max": 2.5},
}
```

```{python}
afficher_quadrant_par_nom(result, config, "SE", quadrants)
```




# Précipitations extrêmes

Evaluation temporelle via la comparaison aux séries annuelles

---

```{python}
year_display_min = config["years"]["min"]
year_display_max = config["years"]["max"]
echelle="quotidien"
title="Comparaison de la moyenne des maxima aux maxima annuels des précipitations"

# Étape 1 : récupérer les résultats avec pipeline_data_quarto
result = pipeline_data_quarto(
    config=config,
    stat_choice="mean-max",
    echelle=echelle,
    min_year=year_display_min,
    max_year=year_display_max,
    season_choice="hydro",
    missing_choice=0.15,
    quantile_choice=0.995
)

# Étape 2 : affichage carte + scatter
_, html_scatter, r2_mean, me_mean, n_mean, _ = pipeline_map_legend_scatter(
    name="jour_mean_max_2000",
    result=result,
    echelle=echelle,
    stat_choice_label="Moyenne des maxima"
)
display(HTML(f"""
    <div style="font-size: 18px; color: #333;">
        <p style="font-size: 22px; font-weight: bold; color: #2c3e50;">{title}</p>
        <p style="font-size: 18px; color: #3498db;">
            de <span style="font-weight: bold; color: #e74c3c;">{year_display_min}</span> à <span style="font-weight: bold; color: #e74c3c;">{year_display_max}</span> 
            (Saison : <span style="font-weight: bold; color: #f39c12;">année hydrologique</span> | Echelle : <span style="font-weight: bold; color: #f39c12;">{echelle}</span>)
        </p> 
    </div>    
"""))
```

```{python}
from app.modules import all_max

from app.utils.scatter_plot_utils import generate_scatter_plot_interactive
from app.utils.stats_utils import generate_metrics

year_display_min = config["years"]["min"]
year_display_max = config["years"]["max"]
year_display_middle = 2000
height = 500
unit_choice = "mm/j"

df_all, df_r2_all_max, _ = all_max.show(config_path, year_display_min, year_display_max, year_display_middle)

# Ajout du scatter plot pour AROME vs station annuels
fig_r2_all_max_hydro_jour = generate_scatter_plot_interactive(
    df=df_all.rename({"lat_obs": "lat", "lon_obs": "lon"}),
    stat_choice="",
    unit_label=unit_choice,
    height=height-60
)
fig_r2_all_max_hydro_jour.update_layout(
    template="simple_white",
    margin=dict(l=100, r=0, t=50, b=50),
    xaxis=dict(title=dict(text=f"AROME ({unit_choice})"), showticklabels=True),
    yaxis=dict(title=dict(text=f"Stations ({unit_choice})"), showticklabels=True)
)
me_all, _, _, r2_all = generate_metrics(df_all)
scatter_path = "assets/fig_r2_all_max_hydro_jour.html"
pio.write_html(fig_r2_all_max_hydro_jour, file=scatter_path, include_plotlyjs="cdn", full_html=False)
```

::: {.columns style="display: flex; gap: 0px; margin: 0;"}
::: {.column width="50%"}
```{python}
display(HTML('<div style="text-align: center; font-weight: bold;">Moyenne des maxima</div>'))
display(HTML(html_scatter))
```
:::
::: {.column width="50%"}
```{python}
display(HTML('<div style="text-align: center; font-weight: bold;">Maxima annuels</div>'))
display(HTML(f"""
    <div style="height: {height-10}px; border: 1px solid #ccc; border-radius: 6px; display: flex; align-items: center; justify-content: center; overflow: hidden; margin-top: 10px;">
        <iframe loading="lazy" src="{scatter_path}" width="100%" height="100%" frameborder="0" style="flex: 3; width: 0; min-width: 0; max-width: 100%;"></iframe>
    </div>

    <div class="metric-caption">
        <strong>r²</strong> = {r2_all:.3f} &nbsp;|&nbsp; <strong>ME</strong> = {me_all:.3f} &nbsp;|&nbsp; <strong>n</strong> = {df_all.shape[0]:.0f}
    </div>
"""))
```
:::
:::

---


```{python}
title = "Comparaison de la moyenne des maxima aux maxima annuels des précipitations suivant la saison et l'échelle"
display(HTML(f"""
    <div style="font-size: 18px; color: #333;">
        <p style="font-size: 22px; font-weight: bold; color: #2c3e50;">{title}</p>
        <p style="font-size: 18px; color: #3498db;">
            de <span style="font-weight: bold; color: #e74c3c;">{year_display_min}</span> à <span style="font-weight: bold; color: #e74c3c;">{year_display_max}</span> 
            pour l'échelle : <span style="font-weight: bold; color: #f39c12;">quotidien</span>
            et de <span style="font-weight: bold; color: #e74c3c;">{year_display_middle}</span> à <span style="font-weight: bold; color: #e74c3c;">{year_display_max}</span> 
            pour l'échelle : <span style="font-weight: bold; color: #f39c12;">horaire</span>
        </p> 
    </div>    
"""))
```

```{python}
df_r2_all_max["Echelle"] = pd.Categorical(df_r2_all_max["Echelle"], categories=["Journalière", "Horaire"], ordered=True)
# Création de la figure avec px.bar
fig_r2_all_max = px.bar(
    df_r2_all_max,
    x="Saison",
    y="r²",
    color="Type",
    text="r²",
    barmode="group",
    facet_col="Echelle",
    category_orders={"Echelle": ["Journalière", "Horaire"]},
    title="",
    facet_col_spacing=0.1,
    height=500-100
)

# Positionne automatiquement le texte au bon endroit
fig_r2_all_max.update_traces(texttemplate="%{text:.2f}", textposition="outside")

# Optionnel : ajuste les marges ou la taille si les textes dépassent
fig_r2_all_max.update_layout(uniformtext_minsize=8, uniformtext_mode='hide')

# Définir une palette manuelle cohérente
color_map = {
    "Moyenne des maxima": px.colors.qualitative.Plotly[0],
    "Maxima annuels": px.colors.qualitative.Plotly[1]    
}

fig_r2_all_max.update_layout(
    template="simple_white",
    legend_title_text=None
)
fig_r2_all_max.update_xaxes(title=None, tickangle=0)

# Appliquer la couleur à chaque trace selon son nom de légende
for trace in fig_r2_all_max.data:
    trace.marker.color = color_map.get(trace.name, "#888888")

fig_r2_path = f"assets/fig_r2_all_max.html"
pio.write_html(fig_r2_all_max, file=fig_r2_path, include_plotlyjs="cdn", full_html=False)

display(HTML(f"""
    <div style="height: {height-10}px; border: 1px solid #ccc; border-radius: 6px; display: flex; align-items: center; justify-content: center; overflow: hidden; margin-top: 10px;">
        <iframe loading="lazy" src="{fig_r2_path}" width="100%" height="100%" frameborder="0" style="flex: 3; width: 0; min-width: 0; max-width: 100%;"></iframe>
    </div>
"""))
```

- Bonne distribution
- Mais difficulté de la modélisation évènementielle ?

# Application GEV (μ, σ, ξ)

```{python}
# Liste complète des modèles avec leurs équations explicites
model_options = {
    "M₁(μ₀, σ₀) : μ(t) = μ₀ ; σ(t) = σ₀ ; ξ(t) = ξ": "s_gev",
    "M₂(μ, σ₀) : μ(t) = μ₀ + μ₁·t ; σ(t) = σ₀ ; ξ(t) = ξ": "ns_gev_m1",
    "M₃(μ₀, σ) : μ(t) = μ₀ ; σ(t) = σ₀ + σ₁·t ; ξ(t) = ξ": "ns_gev_m2",
    "M₄(μ, σ) : μ(t) = μ₀ + μ₁·t ; σ(t) = σ₀ + σ₁·t ; ξ(t) = ξ": "ns_gev_m3"
}
model_labels = {v: k.split(" :")[0] for k, v in model_options.items()}
```


```{python}
import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import genextreme

# Définir la grille x
x = np.linspace(-10, 20, 1000)

# Paramètres à illustrer
mu_values = [-5, 0, 5]
sigma_values = [1, 2, 4]
xi_values = [-0.5, 0.0, 0.5]

# Création de la figure avec 3 colonnes
fig, axes = plt.subplots(1, 3, figsize=(15, 4), constrained_layout=True)

# Style épuré sans ticks numériques, mais avec axes visibles
for ax in axes:
    # Affiche les axes (left et bottom)
    ax.spines['left'].set_visible(True)
    ax.spines['bottom'].set_visible(True)
    # Supprime top et right
    ax.spines['top'].set_visible(False)
    ax.spines['right'].set_visible(False)
    # Supprime les ticks chiffrés
    ax.set_xticks([])
    ax.set_yticks([])
    ax.tick_params(left=False, bottom=False, labelleft=False, labelbottom=False)

# 1. Effet de μ
for mu in mu_values:
    y = genextreme.pdf(x, c=-0.1, loc=mu, scale=2)
    axes[0].plot(x, y, label=f"$\\mu$ = {mu}")
axes[0].set_title("Effet de $\\mu$ (position)", loc='right')
axes[0].set_xlabel("x")
axes[0].set_ylabel("Densité")
axes[0].legend(frameon=False, fontsize=9)

# 2. Effet de σ
for sigma in sigma_values:
    y = genextreme.pdf(x, c=-0.1, loc=0, scale=sigma)
    axes[1].plot(x, y, label=f"$\\sigma$ = {sigma}")
axes[1].set_title("Effet de $\\sigma$ (échelle)", loc='right')
axes[1].set_xlabel("x")
axes[1].legend(frameon=False, fontsize=9)

# 3. Effet de ξ
for xi in xi_values:
    y = genextreme.pdf(x, c=-xi, loc=0, scale=2)
    axes[2].plot(x, y, label=f"$\\xi$ = {xi}")
axes[2].set_title("Effet de $\\xi$ (forme)", loc='right')
axes[2].set_xlabel("x")
axes[2].legend(frameon=False, fontsize=9)

plt.show()
```

::: {.table .striped}

Soit :

| Modèle | μ(t)            | σ(t)            | ξ(t) |
|--------|------------------|------------------|------|
| M₁     | μ₀               | σ₀               | ξ    |
| M₂     | μ₀ + μ₁·t        | σ₀               | ξ    |
| M₃     | μ₀               | σ₀ + σ₁·t        | ξ    |
| M₄     | μ₀ + μ₁·t        | σ₀ + σ₁·t        | ξ    |

:::


---

```{python}
title = "Modèle minimisant l'AIC"
```


```{python}
echelle = "quotidien"
mod_dir = Path(config["gev"]["modelised"]) / echelle
obs_dir = Path(config["gev"]["observed"]) / echelle

df_model_aic = pl.read_parquet(mod_dir / "gev_param_best_model.parquet")
df_obs_aic = pl.read_parquet(obs_dir / "gev_param_best_model.parquet")

df_model_aic = add_metadata(df_model_aic, "mm_h" if echelle == "horaire" else "mm_j", type="modelised")
df_obs_aic = add_metadata(df_obs_aic, "mm_h" if echelle == "horaire" else "mm_j", type="observed")

df_model_aic = filter_nan(df_model_aic, "xi") # xi est toujours valable
df_obs_aic = filter_nan(df_obs_aic, "xi") # xi est toujours valable

df_model_aic = df_model_aic.with_columns(
    pl.col("model").replace(model_labels)  # remplace par noms lisibles
)
df_obs_aic = df_obs_aic.with_columns(
    pl.col("model").replace(model_labels)
)

# liste ordonnée des modèles
categories = list(model_labels.values())  # ["M₁(μ₀, σ₀)", "M₂(μ, σ₀)", ...]
result = {
    "modelised": df_model_aic,
    "modelised_show": df_model_aic,
    "observed": df_obs_aic,
    "observed_show": df_obs_aic,
    "column": "model"
}

deck, legend = pipeline_map_quarto(
    column="model",
    result=result,
    unit_label="",
    continu=False,
    categories=categories,
    n_colors=len(categories)
)

# Enregistrement de la carte
deck.to_html(f"assets/deck_map_jour_model_min_AIC.html", notebook_display=False)

# Affichage côte à côte
html_map_legend = f"""
<div style="display: flex; flex-direction: row; align-items: flex-start; margin-top: 10px;">
    <iframe loading="lazy" src="assets/deck_map_jour_model_min_AIC.html" height=500px frameborder="0" style="flex: 3; width: 0; min-width: 0; max-width: 100%;"></iframe>
    <div style="flex: 1; max-width: 220px; margin-left: 5px;">{legend}</div>
</div>
"""

display(HTML(f"""
    <div style="font-size: 18px; color: #333;">
        <p style="font-size: 22px; font-weight: bold; color: #2c3e50;">{title}</p>
        <p style="font-size: 18px; color: #3498db;">
            de <span style="font-weight: bold; color: #e74c3c;">{year_display_min}</span> à <span style="font-weight: bold; color: #e74c3c;">{year_display_max}</span> 
            (Saison : <span style="font-weight: bold; color: #f39c12;">année hydrologique</span> | Echelle : <span style="font-weight: bold; color: #f39c12;">{echelle}</span>)
        </p> 
    </div>
"""))
```

::: {.columns style="display: flex; gap: 0px; margin: 0;"}
::: {.column width="50%"}
```{python}
display(HTML(html_map_legend))
```
:::

```{python}
import plotly.graph_objects as go

# Mapping des noms vers leur affichage en unicode/math
param_display = {
    "mu0": "μ₀",
    "mu1": "μ₁",
    "sigma0": "σ₀",
    "sigma1": "σ₁",
    "xi": "ξ"
}

df_model_aic = df_model_aic.with_columns(pl.col("NUM_POSTE").cast(pl.Int32))
df_obs_aic = df_obs_aic.with_columns(pl.col("NUM_POSTE").cast(pl.Int32))
df_obs_vs_mod_full = pl.read_csv(f"data/metadonnees/obs_vs_mod/obs_vs_mod_{echelle}.csv")

r2_values = {}
params = ["mu0", "mu1", "sigma0", "sigma1", "xi"]

for param in params:
    obs_vs_mod = match_and_compare(df_obs_aic, df_model_aic, param, df_obs_vs_mod_full)

    if obs_vs_mod is not None and obs_vs_mod.height > 0:
        _, _, _, r2 = generate_metrics(obs_vs_mod)
        r2_values[param_display[param]] = r2
    else:
        r2_values[param_display[param]] = None  # ou np.nan si tu préfères

# Préparation des données pour l'histogramme
labels = list(r2_values.keys())
values = [r2_values[label] if r2_values[label] is not None else 0 for label in labels]
colors = ["grey" if r2_values[label] is not None else "white" for label in labels]

# Création de la figure Plotly
fig_r2_all_max = go.Figure(data=[
    go.Bar(x=labels, y=values, marker_color=colors, text=[f"{v:.3f}" if r2_values[l] is not None else "NA" for l, v in zip(labels, values)],
           textposition="outside")
])

fig_r2_all_max.update_layout(
    title="",
    xaxis_title="Paramètre",
    yaxis_title="r² (AROME - Stations)",
    yaxis=dict(range=[0, 1])
)

# Appliquer le template
fig_r2_all_max.update_layout(template="simple_white")

# Sauvegarde et affichage dans un iframe
scatter_path = f"assets/hist_r2_jour_model_min_AIC.html"
pio.write_html(fig_r2_all_max, file=scatter_path, include_plotlyjs="cdn", full_html=False)

html_scatter = f"""
<div style="height: 500px; border: 1px solid #ccc; border-radius: 6px; display: flex; align-items: center; justify-content: center; overflow: hidden; margin-top: 10px;">
    <iframe loading="lazy" src="{scatter_path}" width="100%" height="100%" frameborder="0" style="flex: 3; width: 0; min-width: 0; max-width: 100%;"></iframe>
</div>
"""
```

::: {.column width="50%"}
```{python}
display(HTML(html_scatter))
```
:::
:::

# Niveau de retour
  
$$
z_T(t) =
\begin{cases}
\mu(t) + \dfrac{\sigma(t)}{\xi} \left[ \left( -\log \left( 1 - \dfrac{1}{T} \right) \right)^{-\xi} - 1 \right] & \text{si } \xi \ne 0 \\\\
\mu(t) - \sigma(t) \log \left( -\log \left( 1 - \dfrac{1}{T} \right) \right) & \text{si } \xi = 0
\end{cases}
$$

--- 

```{python}
echelle = "quotidien"
unit_choice = "mm/j"
quantile_choice = 0.999

stat_choice_label = "Niveau de retour T=20 ans"
T_choice = 20

min_year_choice = config["years"]["min"]
max_year_choice = config["years"]["max"]

mod_dir = Path(config["gev"]["modelised"]) / echelle
obs_dir = Path(config["gev"]["observed"]) / echelle

df_modelised = pl.read_parquet(mod_dir / "gev_param_s_gev.parquet")
df_observed = pl.read_parquet(obs_dir / "gev_param_s_gev.parquet")

df_modelised = filter_nan(df_modelised, "xi") # xi est toujours valable   
df_observed = filter_nan(df_observed, "xi") # xi est toujours valable

df_modelised = add_metadata(df_modelised, "mm_h" if echelle == "horaire" else "mm_j", type="modelised")
df_observed = add_metadata(df_observed, "mm_h" if echelle == "horaire" else "mm_j", type="observed")       


t_norm = 0 # stationnaire
df_modelised = df_modelised.with_columns([
    pl.lit("s_gev").alias("model"),
    pl.lit(0).alias("mu1"),
    pl.lit(0).alias("sigma1")
])
df_observed = df_observed.with_columns([
    pl.lit("s_gev").alias("model"),
    pl.lit(0).alias("mu1"),
    pl.lit(0).alias("sigma1")
])

# Période de retour choisie sous forme de tableau numpy (même un seul T)
T_array = np.array([T_choice])

# Crée la colonne avec compute_return_levels_ns
df_modelised = df_modelised.with_columns(
    pl.struct(["mu0", "mu1", "sigma0", "sigma1", "xi"]).map_elements(
        lambda row: safe_compute_return(row, T_array, t_norm),
        return_dtype=pl.Float64
    ).alias("qT")
)

df_observed = df_observed.with_columns(
    pl.struct(["mu0", "mu1", "sigma0", "sigma1", "xi"]).map_elements(
        lambda row: safe_compute_return(row, T_array, t_norm),
        return_dtype=pl.Float64
    ).alias("qT")
)

df_modelised_show = dont_show_extreme(df_modelised, "qT", quantile_choice, stat_choice_key=None)
df_observed_show = dont_show_extreme(df_observed, "qT", quantile_choice, stat_choice_key=None)

result = {
    "modelised": df_modelised,
    "modelised_show": df_modelised_show,
    "observed": df_observed,
    "observed_show": df_observed_show,
    "column": "qT"
}
# Étape 2 : affichage carte + scatter
html_map_legend, html_scatter, r2, me, n, _ = pipeline_map_legend_scatter(
    name=f"retour_{T_choice}_stationnaire",
    result=result,
    echelle=echelle,
    stat_choice_label="Niveau de retour 20 stationnaire"
)

title = f"Niveau de retour {T_choice} sans effet temporel"
display(HTML(f"""
    <div style="font-size: 18px; color: #333;">
        <p style="font-size: 22px; font-weight: bold; color: #2c3e50;">{title}</p>
        <p style="font-size: 18px; color: #3498db;">
            de <span style="font-weight: bold; color: #e74c3c;">{year_display_min}</span> à <span style="font-weight: bold; color: #e74c3c;">{year_display_max}</span> 
            (Saison : <span style="font-weight: bold; color: #f39c12;">année hydrologique</span> | Echelle : <span style="font-weight: bold; color: #f39c12;">{echelle}</span>)
        </p> 
    </div>
"""))
```


::: {.columns style="display: flex; gap: 0px; margin: 0;"}
::: {.column width="50%"}
```{python}
display(HTML(html_map_legend))
```
:::
::: {.column width="50%"}
```{python}
display(HTML(html_scatter))
```
:::
:::


# Changement du niveau de retour par 10 ans

---

```{python}
# Remplace les valeurs manquantes (None) par 0 pour les paramètres manquants
def ensure_mu1_sigma1(df: pl.DataFrame) -> pl.DataFrame:
    cols = df.columns
    df_new = df
    if "mu1" not in cols:
        df_new = df_new.with_columns(pl.lit(0.0).alias("mu1"))
    else:
        df_new = df_new.with_columns(pl.col("mu1").fill_null(0.0))
    if "sigma1" not in cols:
        df_new = df_new.with_columns(pl.lit(0.0).alias("sigma1"))
    else:
        df_new = df_new.with_columns(pl.col("sigma1").fill_null(0.0))
    return df_new
```

```{python}
from app.pipelines.import_map import pipeline_map
T_choice = 20
echelle="quotidien"
quantile_choice = 0.9999
models = ["ns_gev_m1", "ns_gev_m2", "ns_gev_m3", "best_model"]

# Bornes des années utilisées pour la standardisation
min_year, max_year = config["years"]["min"], config["years"]["max"]
std_year = (max_year - min_year) / 2  # σₜ = (max - min) / 2

# Lecture des données GEV
mod_dir = Path(config["gev"]["modelised"]) / echelle
obs_dir = Path(config["gev"]["observed"]) / echelle

html_all = '<div style="display: flex; justify-content: space-between; gap: 1%;">'

all_deltas = []

log_term = -np.log(1 - 1 / T_choice)

for model in models:
    for typ, dir_ in [("modelised", mod_dir), ("observed", obs_dir)]:
        df = pl.read_parquet(dir_ / f"gev_param_{model}.parquet")
        df = filter_nan(df, "xi")
        df = add_metadata(df, "mm_j", type=typ)

        df = ensure_mu1_sigma1(df)

        mu1_natural = df["mu1"] / std_year
        sigma1_natural = df["sigma1"] / std_year
        xi = df["xi"]

        C_T = (log_term ** (-xi)) - 1
        delta_qT = (mu1_natural + (sigma1_natural / xi) * C_T) * 10

        all_deltas.append(delta_qT.to_numpy())

# Concatène tous les delta_qT
all_values = np.concatenate(all_deltas)

# Calcule des bornes globales sur l'ensemble des modèles + obs
vmin_global = np.nanpercentile(all_values, 0)
vmax_global = np.nanpercentile(all_values, quantile_choice * 100)

# CENTRER EN 0
abs_max = max(abs(vmin_global), abs(vmax_global))
vmin_global = -abs_max
vmax_global = abs_max


for model in models:
    df_modelised = pl.read_parquet(mod_dir / f"gev_param_{model}.parquet")
    df_observed = pl.read_parquet(obs_dir / f"gev_param_{model}.parquet")

    df_modelised = filter_nan(df_modelised, "xi") # xi est toujours valable   
    df_observed = filter_nan(df_observed, "xi") # xi est toujours valable

    df_modelised = add_metadata(df_modelised, "mm_h" if echelle == "horaire" else "mm_j", type="modelised")
    df_observed = add_metadata(df_observed, "mm_h" if echelle == "horaire" else "mm_j", type="observed")

    df_modelised = ensure_mu1_sigma1(df_modelised)
    df_observed = ensure_mu1_sigma1(df_observed)

    column_to_show = "delta_qT"

    # Conversion des dérivées ∂qT/∂t du temps standardisé → temps réel
    # ∂μ/∂tₙᵒʳᵐ = μ₁  donc ∂μ/∂année = μ₁ / σₜ
    # ∂σ/∂année = σ₁ / σₜ
    mu1_natural = pl.col("mu1") / std_year
    sigma1_natural = pl.col("sigma1") / std_year

    # Calcul du terme C_T :  Cₜ = (−log(1−1/T))^(−ξ) − 1
    log_term = -np.log(1 - 1 / T_choice)
    C_T_expr = (log_term ** (-pl.col("xi"))) - 1

    # Variation décennale de qT :
    # ΔqT = (μ₁ + (σ₁ / ξ) × Cₜ) × 10   (dans l’espace temporel réel)
    df_modelised_delta = df_modelised.with_columns([
        ((mu1_natural + (sigma1_natural / pl.col("xi")) * C_T_expr) * 10).alias("delta_qT")
    ])
    df_observed_delta = df_observed.with_columns([
        ((mu1_natural + (sigma1_natural / pl.col("xi")) * C_T_expr) * 10).alias("delta_qT")
    ])


    ### MAP
    df_modelised_show = dont_show_extreme(df_modelised_delta, column_to_show, quantile_choice, stat_choice_key=None)
    df_observed_show = dont_show_extreme(df_observed_delta, column_to_show, quantile_choice, stat_choice_key=None)

    # Chargement des affichages graphiques
    result = {
        "modelised": df_modelised_delta,
        "modelised_show": df_modelised_show,
        "observed": df_observed_delta,
        "observed_show": df_observed_show,
        "column": column_to_show,
        "vmin": vmin_global,
        "vmax": vmax_global,
        "echelle": "diverging_zero_white"
    }

    # Étape 2 : affichage carte + scatter
    html_map_legend, _, r2, _, n, _ = pipeline_map_legend_scatter(
        name=f"changement_retour_{T_choice}_{model}",
        result=result,
        echelle=echelle,
        stat_choice_label="Moyenne des précipitations"
    )
    html_all += f"""
    <div style="width: 24%; font-size: 0.8em;">
        <strong>{model_labels.get(model, model)}</strong><br>
        {html_map_legend}
        <strong>r²</strong> = {r2:.3f}<br>
        <strong>n</strong> = {n}
    </div>
    """

html_all += "</div>"
title = f"Changement du niveau de retour {T_choice} ans par 10 ans"
display(HTML(f"""
    <div style="font-size: 18px; color: #333;">
        <p style="font-size: 22px; font-weight: bold; color: #2c3e50;">{title}</p>
        <p style="font-size: 18px; color: #3498db;">
            de <span style="font-weight: bold; color: #e74c3c;">{year_display_min}</span> à <span style="font-weight: bold; color: #e74c3c;">{year_display_max}</span> 
            (Saison : <span style="font-weight: bold; color: #f39c12;">année hydrologique</span> | Echelle : <span style="font-weight: bold; color: #f39c12;">{echelle}</span>)
        </p> 
    </div>
"""))
display(HTML(html_all))
```
