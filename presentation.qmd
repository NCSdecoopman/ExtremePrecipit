---
title: "Avancement du stage"
author: Decoopman Nicolas
format:
  revealjs:
    theme: simple
    slide-number: true
    pdf-separate-fragments: false
    toc: false
    width: 1280
    height: 720
    self-contained: false 
    allow-scripts: true 
    css: presentation/styles.css
execute:
  cache: true
  echo: false
  warning: false
  message: false
  error: true
freeze: auto  
jupyter: stage
---

```{python}
#| label: import
# Imports
import yaml
from pathlib import Path
import pandas as pd
import polars as pl
import numpy as np
import plotly.express as px
from IPython.display import display, HTML, Markdown
import plotly.io as pio

from app.utils.data_utils import (
    match_and_compare,
    add_metadata,
    dont_show_extreme,
    standardize_year,
    filter_nan
)
from app.utils.stats_utils import generate_metrics
from app.pipelines.import_quarto import (
    pipeline_data_quarto, pipeline_data_gev_quarto,
    pipeline_map_quarto,
    pipeline_map_legend_scatter,
    pipeline_title, pipeline_show_html,
    pipeline_quarto_gev_half_france
)

# Charger les param√®tres depuis config.yaml
config_path = Path("app/config/config.yaml")
with open(config_path, "r") as f:
    config = yaml.safe_load(f)

def pipeline_total_title_map_legend_scatter_delta(
    title: str,
    year_min: int,
    year_max: int,
    echelle: str,
    html_map_legend: str,
    html_scatter: str,
    season_choice: str="hydro",
    me: int=None,
    percent: int=None,
    r2: int=None,
    unit: str=None,
    nb_after_comma: int=1
):
    if unit is None:
        unit = "mm/j" if echelle == "quotidien" else "mm/h"


    title_show = pipeline_title(title, year_min, year_max, echelle, season_choice)
    display(HTML(title_show))
    display(HTML(pipeline_show_html(html_map_legend, html_scatter)))
    
    if r2 is not None:
        display(HTML(f"r¬≤ = {r2:+.3f}"))
    elif me is not None:
        if percent is not None:
            display(HTML(f"Œî (AROME - Stations) : {me:+.{nb_after_comma}f} {unit} ({percent*100:+.1f}%)"))
        else:
            display(HTML(f"Œî (AROME - Stations) : {me:+.{nb_after_comma}f} {unit}"))
```


## Pr√©cipitations extr√™mes horaires en France

<br><br>

### 1. Objectif
Analyser les tendances des pr√©cipitations extr√™mes horaires en France (1959‚Äì2022) √† partir du mod√®le CP-RCM CNRM-AROME (2.5 km) forc√© par ERA5
<br>

### 2. M√©thodes

- GEV stationnaire et non stationnaire
- Comparaison avec observations M√©t√©o-France (+ EDF ?)
<br>

### 3. Enjeux

- Effet du r√©chauffement climatique sur les extr√™mes
- Zones √† forte variabilit√© (Alpes, M√©diterran√©e)
- Contribution √† la connaissance du risque hydrom√©t√©o


# AROME vs. stations

Nombre de jours de pluie

---

```{python}
#| label: jours_pluie_total
title="Nombre de jour de pluie moyen"
year_display_min = config["years"]["min"]
year_display_max = config["years"]["max"]
echelle="quotidien"

# √âtape 1 : r√©cup√©rer r√©sultats avec pipeline_data_quarto
result = pipeline_data_quarto(
    config=config,
    stat_choice="numday",
    echelle=echelle,
    min_year=year_display_min,
    max_year=year_display_max,
    season_choice="hydro",
    unit_choice="jours",
    missing_choice=0.15,
    quantile_choice=0.995
)

# √âtape 2 : affichage carte + scatter
html_map_legend, html_scatter, r2, me, n, percent = pipeline_map_legend_scatter(
    name="jour_pluie_total",
    result=result,
    echelle=echelle,
    stat_choice_label=title,
    unit_choice="jours"
)

pipeline_total_title_map_legend_scatter_delta(
    title=title,
    year_min=year_display_min,
    year_max=year_display_max,
    echelle=echelle,
    html_map_legend=html_map_legend,
    html_scatter=html_scatter,
    me=me,
    percent=percent,
    unit="jours"
)
```

- tendance √† d√©clencher des jours de pluie plus fr√©quemment que ce qui est observ√©  
- trop sensible au seuil de 1 mm/j qui serait √† augmenter ?

---



```{python}
#| label: jours_pluie_2000_MAX
year_display_min = 2000
year_display_max = config["years"]["max"]
echelle="quotidien"

# √âtape 1 : r√©cup√©rer les r√©sultats avec pipeline_data_quarto
result = pipeline_data_quarto(
    config=config,
    stat_choice="numday",
    echelle=echelle,
    min_year=year_display_min,
    max_year=year_display_max,
    season_choice="hydro",
    unit_choice="jours",
    missing_choice=0.15,
    quantile_choice=0.995
)

# √âtape 2 : affichage carte + scatter
html_map_legend, html_scatter, r2, me, n, percent = pipeline_map_legend_scatter(
    name="jour_pluie_2000",
    result=result,
    echelle=echelle,
    stat_choice_label="Jour de pluie",
    unit_choice="jours"
)

pipeline_total_title_map_legend_scatter_delta(
    title=title,
    year_min=year_display_min,
    year_max=year_display_max,
    echelle=echelle,
    html_map_legend=html_map_legend,
    html_scatter=html_scatter,
    me=me,
    percent=percent,
    unit="jours"
)
```


# AROME vs. stations

Cumul des pr√©cipitations

---

```{python}
#| label: moy_precipit_jour_total
title="Cumul des pr√©cipitations"
year_display_min = config["years"]["min"]
year_display_max = config["years"]["max"]
echelle="quotidien"

# √âtape 1 : r√©cup√©rer les r√©sultats avec pipeline_data_quarto
result = pipeline_data_quarto(
    config=config,
    stat_choice="mean",
    echelle=echelle,
    min_year=year_display_min,
    max_year=year_display_max,
    season_choice="hydro",
    missing_choice=0.15,
    quantile_choice=0.995
)

# √âtape 2 : affichage carte + scatter
html_map_legend, html_scatter, r2, me, n, percent = pipeline_map_legend_scatter(
    name="jour_mean_total",
    result=result,
    echelle=echelle,
    stat_choice_label="Moyenne des pr√©cipitations"
)

pipeline_total_title_map_legend_scatter_delta(
    title=title,
    year_min=year_display_min,
    year_max=year_display_max,
    echelle=echelle,
    html_map_legend=html_map_legend,
    html_scatter=html_scatter,
    me=me,
    percent=percent,
    nb_after_comma=3
)
```

```{python}
#| label: moy_precipit_jour_2000_MAX_only_metric
year_display_min = 2000
year_display_max = config["years"]["max"]
echelle="quotidien"

# √âtape 1 : r√©cup√©rer les r√©sultats avec pipeline_data_quarto
result = pipeline_data_quarto(
    config=config,
    stat_choice="mean",
    echelle=echelle,
    min_year=year_display_min,
    max_year=year_display_max,
    season_choice="hydro",
    missing_choice=0.15,
    quantile_choice=0.995
)

# √âtape 2 : affichage carte + scatter
_, _, _, me, _, percent = pipeline_map_legend_scatter(
    name="jour_mean_2000",
    result=result,
    echelle=echelle,
    stat_choice_label="Moyenne des pr√©cipitations"
)
display(HTML(f"Œî (AROME - Stations) de {year_display_min} √† {year_display_max} : {me:+.3f} mm/j ({percent*100:+.1f}%)"))
```


- R√©partition correcte de la quantit√© totale d‚Äôeau 

---

```{python}
#| label: moy_precipit_horaire_2000_MAX
year_display_min = 2000
year_display_max = config["years"]["max"]
echelle="horaire"

# √âtape 1 : r√©cup√©rer les r√©sultats avec pipeline_data_quarto
result = pipeline_data_quarto(
    config=config,
    stat_choice="mean",
    echelle=echelle,
    min_year=year_display_min,
    max_year=year_display_max,
    season_choice="hydro",
    missing_choice=0.15,
    quantile_choice=0.995
)

# √âtape 2 : affichage carte + scatter
html_map_legend, html_scatter, r2, me, n, percent = pipeline_map_legend_scatter(
    name="horaire_mean_2000",
    result=result,
    echelle=echelle,
    stat_choice_label="Moyenne des pr√©cipitations"
)

pipeline_total_title_map_legend_scatter_delta(
    title=title,
    year_min=year_display_min,
    year_max=year_display_max,
    echelle=echelle,
    html_map_legend=html_map_legend,
    html_scatter=html_scatter,
    me=me,
    percent=percent,
    nb_after_comma=3
)
```

- R√©sultat semblable

# Conclusion : avec AROME il y a des pluies...


- **plus fr√©quentes**... surestime le nombre de jours de pluie  
- **en plus faible quantit√©**... mais pas le cumul

# Pr√©cipitations extr√™mes

Evaluation des structures spatiales via les valeurs moyenn√©es sur la p√©riode

---

```{python}
#| label: moy_max_precipit_jour_total
title="Moyenne des maxima des pr√©cipitations"
year_display_min = config["years"]["min"]
year_display_max = config["years"]["max"]
echelle="quotidien"

# √âtape 1 : r√©cup√©rer les r√©sultats avec pipeline_data_quarto
result = pipeline_data_quarto(
    config=config,
    stat_choice="mean-max",
    echelle=echelle,
    min_year=year_display_min,
    max_year=year_display_max,
    season_choice="hydro",
    missing_choice=0.15,
    quantile_choice=0.995
)

# √âtape 2 : affichage carte + scatter
html_map_legend, html_scatter, r2, me, n, percent = pipeline_map_legend_scatter(
    name="jour_mean_max_total",
    result=result,
    echelle=echelle,
    stat_choice_label="Moyenne des maxima"
)

pipeline_total_title_map_legend_scatter_delta(
    title=title,
    year_min=year_display_min,
    year_max=year_display_max,
    echelle=echelle,
    html_map_legend=html_map_legend,
    html_scatter=html_scatter,
    me=me,
    percent=percent,
    nb_after_comma=3
)
```

```{python}
#| label: moy_max_precipit_jour_2000_MAX
year_display_min = 2000
year_display_max = config["years"]["max"]
echelle="quotidien"

# √âtape 1 : r√©cup√©rer les r√©sultats avec pipeline_data_quarto
result = pipeline_data_quarto(
    config=config,
    stat_choice="mean-max",
    echelle=echelle,
    min_year=year_display_min,
    max_year=year_display_max,
    season_choice="hydro",
    missing_choice=0.15,
    quantile_choice=0.995
)

# √âtape 2 : affichage carte + scatter
_, _, _, me, _, percent = pipeline_map_legend_scatter(
    name="jour_mean_max_2000",
    result=result,
    echelle=echelle,
    stat_choice_label="Moyenne des maxima"
)

display(HTML(f"Œî (AROME - Stations) de {year_display_min} √† {year_display_max} : {me:+.3f} mm/j ({percent*100:+.1f}%)"))
```

- Estimation bruit√©e sur une p√©riode restreinte ?

---

```{python}
#| label: moy_max_precipit_horaire_2000_MAX
year_display_min = 2000
year_display_max = config["years"]["max"]
echelle="horaire"

# √âtape 1 : r√©cup√©rer les r√©sultats avec pipeline_data_quarto
result = pipeline_data_quarto(
    config=config,
    stat_choice="mean-max",
    echelle=echelle,
    min_year=year_display_min,
    max_year=year_display_max,
    season_choice="hydro",
    missing_choice=0.15,
    quantile_choice=0.995
)

# √âtape 2 : affichage carte + scatter
html_map_legend, html_scatter, r2, me, n, percent = pipeline_map_legend_scatter(
    name="horaire_mean_max_2000",
    result=result,
    echelle=echelle,
    stat_choice_label="Moyenne des maxima"
)

pipeline_total_title_map_legend_scatter_delta(
    title=title,
    year_min=year_display_min,
    year_max=year_display_max,
    echelle=echelle,
    html_map_legend=html_map_legend,
    html_scatter=html_scatter,
    me=me,
    percent=percent,
    nb_after_comma=3
)
```

- Rappel : le cumul √©tait bon donc les orages horaires les plus forts ont une faible emprise spatiale ?
- Oui : le regroupement de stations sur une m√™me grille r√©duit le Œî



# Pr√©cipitations extr√™mes

Evaluation temporelle via la comparaison aux s√©ries annuelles

---

```{python}
# | label: moyenne-max_vs_series-max
# suppresion de l'affichage ici
year_display_min = config["years"]["min"]
year_display_max = config["years"]["max"]
echelle="quotidien"
title="Comparaison de la moyenne des maxima aux maxima annuels des pr√©cipitations"
title_show = pipeline_title(title, year_display_min, year_display_max, echelle)
display(HTML(title_show))

# --------------- VALEURS MOYENNES
result = pipeline_data_quarto(
    config=config,
    stat_choice="mean-max",
    echelle=echelle,
    min_year=year_display_min,
    max_year=year_display_max,
    season_choice="hydro",
    missing_choice=0.15,
    quantile_choice=0.995
)

_, html_scatter_mean, r2_mean, me_mean, n_mean, _ = pipeline_map_legend_scatter(
    name="jour_mean_max_total",
    result=result,
    echelle=echelle,
    stat_choice_label="Moyenne des maxima"
)


#  --------------- MAX ANNNUELS
from app.modules import all_max
from app.utils.scatter_plot_utils import generate_scatter_plot_interactive
from app.utils.stats_utils import generate_metrics

year_display_middle, height, unit_choice = 2000, 500, "mm/j"
df_all, df_r2_all_max, _ = all_max.show(config_path, year_display_min, year_display_max, year_display_middle)
df_all = df_all.rename({"lat_obs": "lat", "lon_obs": "lon"})

# Ajout du scatter plot pour AROME vs station annuels
fig_r2_all_max_hydro_jour = generate_scatter_plot_interactive(
    df=df_all,
    stat_choice="",
    unit_label=unit_choice,
    height=height-60
)

fig_r2_all_max_hydro_jour.update_layout(
    template="simple_white",
    margin=dict(l=100, r=0, t=50, b=50),
    xaxis=dict(title=dict(text=f"AROME ({unit_choice})"), showticklabels=True),
    yaxis=dict(title=dict(text=f"Stations ({unit_choice})"), showticklabels=True)
)

me_all, _, _, r2_all = generate_metrics(df_all)
scatter_path = "assets/fig_r2_all_max_hydro_jour.html"
pio.write_html(fig_r2_all_max_hydro_jour, file=scatter_path, include_plotlyjs="cdn", full_html=False)
```

::: {.columns style="display: flex; gap: 0px; margin: 0;"}
::: {.column width="50%"}
```{python}
display(HTML('<div style="text-align: center; font-weight: bold;">Moyenne des maxima</div>'))
display(HTML(html_scatter_mean))
```
:::
::: {.column width="50%"}
```{python}
display(HTML('<div style="text-align: center; font-weight: bold;">Maxima annuels</div>'))
display(HTML(f"""
    <div style="height: {height-10}px; border: 1px solid #ccc; border-radius: 6px; display: flex; align-items: center; justify-content: center; overflow: hidden; margin-top: 10px;">
        <iframe loading="lazy" src="{scatter_path}" width="100%" height="100%" frameborder="0" style="flex: 3; width: 0; min-width: 0; max-width: 100%;"></iframe>
    </div>

    <div class="metric-caption">
        <strong>r¬≤</strong> = {r2_all:.3f} &nbsp;|&nbsp; <strong>ME</strong> = {me_all:.3f} &nbsp;|&nbsp; <strong>n</strong> = {df_all.shape[0]:.0f}
    </div>
"""))
```
:::
:::

---

```{python}
#| label: moyenne-max_vs_series-max_ALL
title = "Comparaison de la moyenne des maxima aux maxima annuels des pr√©cipitations suivant la saison et l'√©chelle"
display(HTML(f"""
    <div style="font-size: 18px; color: #333;">
        <p style="font-size: 22px; font-weight: bold; color: #2c3e50;">{title}</p>
        <p style="font-size: 18px; color: #3498db;">
            de <span style="font-weight: bold; color: #e74c3c;">{year_display_min}</span> √† <span style="font-weight: bold; color: #e74c3c;">{year_display_max}</span> 
            pour l'√©chelle : <span style="font-weight: bold; color: #f39c12;">quotidien</span>
            et de <span style="font-weight: bold; color: #e74c3c;">{year_display_middle}</span> √† <span style="font-weight: bold; color: #e74c3c;">{year_display_max}</span> 
            pour l'√©chelle : <span style="font-weight: bold; color: #f39c12;">horaire</span>
        </p> 
    </div>    
"""))

df_r2_all_max["Echelle"] = pd.Categorical(df_r2_all_max["Echelle"], categories=["Journali√®re", "Horaire"], ordered=True)
# Cr√©ation de la figure avec px.bar
fig_r2_all_max = px.bar(
    df_r2_all_max,
    x="Saison",
    y="r¬≤",
    color="Type",
    text="r¬≤",
    barmode="group",
    facet_col="Echelle",
    category_orders={"Echelle": ["Journali√®re", "Horaire"]},
    title="",
    facet_col_spacing=0.1,
    height=500-100
)

# Positionne automatiquement le texte au bon endroit
fig_r2_all_max.update_traces(texttemplate="%{text:.2f}", textposition="outside")

# Optionnel : ajuste les marges ou la taille si les textes d√©passent
fig_r2_all_max.update_layout(uniformtext_minsize=8, uniformtext_mode='hide')

# D√©finir une palette manuelle coh√©rente
color_map = {
    "Moyenne des maxima": px.colors.qualitative.Plotly[0],
    "Maxima annuels": px.colors.qualitative.Plotly[1]    
}

fig_r2_all_max.update_layout(
    template="simple_white",
    legend_title_text=None
)
fig_r2_all_max.update_xaxes(title=None, tickangle=0)

# Appliquer la couleur √† chaque trace selon son nom de l√©gende
for trace in fig_r2_all_max.data:
    trace.marker.color = color_map.get(trace.name, "#888888")

fig_r2_path = f"assets/fig_r2_all_max.html"
pio.write_html(fig_r2_all_max, file=fig_r2_path, include_plotlyjs="cdn", full_html=False)

display(HTML(f"""
    <div style="height: {height-10}px; border: 1px solid #ccc; border-radius: 6px; display: flex; align-items: center; justify-content: center; overflow: hidden; margin-top: 10px;">
        <iframe loading="lazy" src="{fig_r2_path}" width="100%" height="100%" frameborder="0" style="flex: 3; width: 0; min-width: 0; max-width: 100%;"></iframe>
    </div>
"""))
```

- Bonne distribution
- Mais difficult√© de la mod√©lisation √©v√®nementielle ?

# Application GEV (Œº, œÉ, Œæ)

```{python}
#| label: define_gev
# Liste compl√®te des mod√®les avec leurs √©quations explicites
model_options = {
    "M‚ÇÄ(Œº‚ÇÄ, œÉ‚ÇÄ) : Œº(t) = Œº‚ÇÄ ; œÉ(t) = œÉ‚ÇÄ ; Œæ(t) = Œæ": "s_gev",
    "M‚ÇÅ(Œº, œÉ‚ÇÄ) : Œº(t) = Œº‚ÇÄ + Œº‚ÇÅ¬∑t ; œÉ(t) = œÉ‚ÇÄ ; Œæ(t) = Œæ": "ns_gev_m1",
    "M‚ÇÇ(Œº‚ÇÄ, œÉ) : Œº(t) = Œº‚ÇÄ ; œÉ(t) = œÉ‚ÇÄ + œÉ‚ÇÅ¬∑t ; Œæ(t) = Œæ": "ns_gev_m2",
    "M‚ÇÉ(Œº, œÉ) : Œº(t) = Œº‚ÇÄ + Œº‚ÇÅ¬∑t ; œÉ(t) = œÉ‚ÇÄ + œÉ‚ÇÅ¬∑t ; Œæ(t) = Œæ": "ns_gev_m3",
    "M‚ÇÅ‚ãÜ(Œº, œÉ‚ÇÄ) : Œº(t) = Œº‚ÇÄ + Œº‚ÇÅ¬∑t‚Çä ; œÉ(t) = œÉ‚ÇÄ ; Œæ(t) = Œæ en notant t‚Çä = t ¬∑ ùüô_{t > t‚ÇÄ} avec t‚ÇÄ = 1985": "ns_gev_m1_break_year",
    "M‚ÇÇ‚ãÜ(Œº‚ÇÄ, œÉ) : Œº(t) = Œº‚ÇÄ ; œÉ(t) = œÉ‚ÇÄ + œÉ‚ÇÅ¬∑t‚Çä ; Œæ(t) = Œæ en notant t‚Çä = t ¬∑ ùüô_{t > t‚ÇÄ} avec t‚ÇÄ = 1985": "ns_gev_m2_break_year",
    "M‚ÇÉ‚ãÜ(Œº, œÉ) : Œº(t) = Œº‚ÇÄ + Œº‚ÇÅ¬∑t‚Çä ; œÉ(t) = œÉ‚ÇÄ + œÉ‚ÇÅ¬∑t‚Çä ; Œæ(t) = Œæ en notant t‚Çä = t ¬∑ ùüô_{t > t‚ÇÄ} avec t‚ÇÄ = 1985": "ns_gev_m3_break_year",
}
model_labels = {v: k.split(" :")[0] for k, v in model_options.items()}


# Repr√©sentation graphique de GEV classiques
import matplotlib.pyplot as plt
from scipy.stats import genextreme

# D√©finir la grille x
x = np.linspace(-10, 20, 1000)

# Param√®tres √† illustrer
mu_values = [-5, 0, 5]
sigma_values = [1, 2, 4]
xi_values = [-0.5, 0.0, 0.5]

# Cr√©ation de la figure avec 3 colonnes
fig, axes = plt.subplots(1, 3, figsize=(15, 4), constrained_layout=True)

# Style √©pur√© sans ticks num√©riques, mais avec axes visibles
for ax in axes:
    # Affiche les axes (left et bottom)
    ax.spines['left'].set_visible(True)
    ax.spines['bottom'].set_visible(True)
    # Supprime top et right
    ax.spines['top'].set_visible(False)
    ax.spines['right'].set_visible(False)
    # Supprime les ticks chiffr√©s
    ax.set_xticks([])
    ax.set_yticks([])
    ax.tick_params(left=False, bottom=False, labelleft=False, labelbottom=False)

# 1. Effet de Œº
for mu in mu_values:
    y = genextreme.pdf(x, c=-0.1, loc=mu, scale=2)
    axes[0].plot(x, y, label=f"$\\mu$ = {mu}")
axes[0].set_title("Effet de $\\mu$ (position)", loc='right')
axes[0].set_xlabel("x")
axes[0].set_ylabel("Densit√©")
axes[0].legend(frameon=False, fontsize=9)

# 2. Effet de œÉ
for sigma in sigma_values:
    y = genextreme.pdf(x, c=-0.1, loc=0, scale=sigma)
    axes[1].plot(x, y, label=f"$\\sigma$ = {sigma}")
axes[1].set_title("Effet de $\\sigma$ (√©chelle)", loc='right')
axes[1].set_xlabel("x")
axes[1].legend(frameon=False, fontsize=9)

# 3. Effet de Œæ
for xi in xi_values:
    y = genextreme.pdf(x, c=-xi, loc=0, scale=2)
    axes[2].plot(x, y, label=f"$\\xi$ = {xi}")
axes[2].set_title("Effet de $\\xi$ (forme)", loc='right')
axes[2].set_xlabel("x")
axes[2].legend(frameon=False, fontsize=9)

plt.show()
```

---

### Mod√®les sans rupture temporelle

| Mod√®le | Œº(t)              | œÉ(t)              | Œæ(t) |
|:------:|:------------------|:------------------|:-----:|
| M‚ÇÄ     | Œº‚ÇÄ                | œÉ‚ÇÄ                | Œæ    |
| M‚ÇÅ     | Œº‚ÇÄ¬†+¬†Œº‚ÇÅ¬∑t         | œÉ‚ÇÄ                | Œæ    |
| M‚ÇÇ     | Œº‚ÇÄ                | œÉ‚ÇÄ¬†+¬†œÉ‚ÇÅ¬∑t         | Œæ    |
| M‚ÇÉ     | Œº‚ÇÄ¬†+¬†Œº‚ÇÅ¬∑t         | œÉ‚ÇÄ¬†+¬†œÉ‚ÇÅ¬∑t         | Œæ    |


### Mod√®les avec rupture en 1985

<span style="font-size: 1.05em;">Soit</span>
**t‚Çä¬†=¬†t¬†√ó¬†ùüô{t¬†&gt;¬†1985}**,
on a :

| Mod√®le         | Œº(t)                 | œÉ(t)                 | Œæ(t) |
|:--------------:|:---------------------|:---------------------|:-----:|
| M‚ÇÅ‚ãÜ (rupture)  | Œº‚ÇÄ¬†+¬†Œº‚ÇÅ¬∑t‚Çä           | œÉ‚ÇÄ                   | Œæ    |
| M‚ÇÇ‚ãÜ (rupture)  | Œº‚ÇÄ                   | œÉ‚ÇÄ¬†+¬†œÉ‚ÇÅ¬∑t‚Çä           | Œæ    |
| M‚ÇÉ‚ãÜ (rupture)  | Œº‚ÇÄ¬†+¬†Œº‚ÇÅ¬∑t‚Çä           | œÉ‚ÇÄ¬†+¬†œÉ‚ÇÅ¬∑t‚Çä           | Œæ    |



---

```{python}
#| label: minimize_gev_aic_map
echelle = "quotidien"
season = "hydro"
title = f"Mod√®le minimisant l'AIC"
mod_dir = Path(config["gev"]["modelised"]) / echelle / season
obs_dir = Path(config["gev"]["observed"]) / echelle / season

df_model_aic = pl.read_parquet(mod_dir / "gev_param_best_model.parquet")
df_obs_aic = pl.read_parquet(obs_dir / "gev_param_best_model.parquet")

df_model_aic = add_metadata(df_model_aic, "mm_h" if echelle == "horaire" else "mm_j", type="modelised")
df_obs_aic = add_metadata(df_obs_aic, "mm_h" if echelle == "horaire" else "mm_j", type="observed")

df_model_aic = filter_nan(df_model_aic, "xi") # xi est toujours valable
df_obs_aic = filter_nan(df_obs_aic, "xi") # xi est toujours valable

df_model_aic = df_model_aic.with_columns(
    pl.col("model").replace(model_labels)  # remplace par noms lisibles
)
df_obs_aic = df_obs_aic.with_columns(
    pl.col("model").replace(model_labels)
)

result = {
    "modelised": df_model_aic,
    "modelised_show": df_model_aic,
    "observed": df_obs_aic,
    "observed_show": df_obs_aic,
    "column": "model",
    "echelle": "diverging_zero_white",
    "continu": False,
    "categories": list(model_labels.values())  # ["M‚ÇÅ(Œº‚ÇÄ, œÉ‚ÇÄ)", "M‚ÇÇ(Œº, œÉ‚ÇÄ)", ...]
}

html_map_legend = pipeline_map_quarto(
    name="model_minim_AIC",
    result=result,
    echelle=echelle,
    stat_choice_label=None
)

title_show = pipeline_title(title, config["years"]["min"], config["years"]["max"], echelle)
display(HTML(title_show))
```

::: {.columns style="display: flex; gap: 0px; margin: 0;"}
::: {.column width="50%"}
```{python}
display(HTML(html_map_legend))
```
:::

```{python}
#| label: minimize_gev_aic_hist
import plotly.graph_objects as go

# Mapping des noms vers leur affichage en unicode/math
param_display = {
    "mu0": "Œº‚ÇÄ",
    "mu1": "Œº‚ÇÅ",
    "sigma0": "œÉ‚ÇÄ",
    "sigma1": "œÉ‚ÇÅ",
    "xi": "Œæ"
}

df_model_aic = df_model_aic.with_columns(pl.col("NUM_POSTE").cast(pl.Int32))
df_obs_aic = df_obs_aic.with_columns(pl.col("NUM_POSTE").cast(pl.Int32))
df_obs_vs_mod_full = pl.read_csv(f"data/metadonnees/obs_vs_mod/obs_vs_mod_{echelle}.csv")

r2_values = {}
params = ["mu0", "mu1", "sigma0", "sigma1", "xi"]

for param in params:
    obs_vs_mod = match_and_compare(df_obs_aic, df_model_aic, param, df_obs_vs_mod_full)

    if obs_vs_mod is not None and obs_vs_mod.height > 0:
        _, _, _, r2 = generate_metrics(obs_vs_mod)
        r2_values[param_display[param]] = r2
    else:
        r2_values[param_display[param]] = None  # ou np.nan si tu pr√©f√®res

# Pr√©paration des donn√©es pour l'histogramme
labels = list(r2_values.keys())
values = [r2_values[label] if r2_values[label] is not None else 0 for label in labels]
colors = ["grey" if r2_values[label] is not None else "white" for label in labels]

# Cr√©ation de la figure Plotly
fig_r2_all_max = go.Figure(data=[
    go.Bar(x=labels, y=values, marker_color=colors, text=[f"{v:.3f}" if r2_values[l] is not None else "NA" for l, v in zip(labels, values)],
           textposition="outside")
])

fig_r2_all_max.update_layout(
    title="",
    xaxis_title="Param√®tre",
    yaxis_title="r¬≤ (AROME - Stations)",
    yaxis=dict(range=[0, 1])
)

# Appliquer le template
fig_r2_all_max.update_layout(template="simple_white")

# Sauvegarde et affichage dans un iframe
scatter_path = f"assets/hist_r2_jour_model_min_AIC.html"
pio.write_html(fig_r2_all_max, file=scatter_path, include_plotlyjs="cdn", full_html=False)

html_scatter = f"""
<div style="height: 500px; border: 1px solid #ccc; border-radius: 6px; display: flex; align-items: center; justify-content: center; overflow: hidden; margin-top: 10px;">
    <iframe loading="lazy" src="{scatter_path}" width="100%" height="100%" frameborder="0" style="flex: 3; width: 0; min-width: 0; max-width: 100%;"></iframe>
</div>
"""
```

::: {.column width="50%"}
```{python}
display(HTML(html_scatter))
```
:::
:::

---


```{python}
#| label: show_xi
title="Valeurs de Œæ"
echelle="quotidien"

# √âtape 1 : r√©cup√©rer r√©sultats avec pipeline_data_quarto
result = {
    "modelised": df_model_aic,
    "modelised_show": df_model_aic,
    "observed": df_obs_aic,
    "observed_show": df_obs_aic,
    "column": "xi"
}
# √âtape 2 : affichage carte + scatter
html_map_legend, html_scatter, r2, me, n, percent = pipeline_map_legend_scatter(
    name="valeur_de_xi",
    result=result,
    echelle=echelle,
    stat_choice_label=title,
    unit_choice=""
)

pipeline_total_title_map_legend_scatter_delta(
    title=title,
    year_min=config["years"]["min"],
    year_max=config["years"]["max"],
    echelle=echelle,
    html_map_legend=html_map_legend,
    html_scatter=html_scatter,
    me=me,
    percent=percent,
    unit="",
    nb_after_comma=3
)
```

# Changement du niveau de retour

$$
\Delta q^{T}_{X\,\text{ans}} = \frac{X}{\Delta a} \left[\, \mu_1 + \frac{\sigma_1}{\xi}\,z_T \,\right]
$$

o√π¬†:

* $\Delta a$ = dur√©e totale du mod√®le (en ann√©es), par exemple 40 si de 1980 √† 2020
* $X$ = nombre d'ann√©es consid√©r√©es pour la variation (ex‚ÄØ: 10 pour un changement par 10 ans)
* $\mu_1$, $\sigma_1$, $\xi$ = param√®tres du mod√®le GEV non stationnaire (issus de l‚Äôajustement)
* $z_T$ = terme d√©pendant de la p√©riode de retour $T$

$$
z_T = 
\begin{cases}
\displaystyle
\left[ -\log\left(1 - \frac{1}{T}\right) \right]^{-\xi} - 1 & \text{si } \xi \neq 0 \\\\
\displaystyle
\log \left( -\log\left(1 - \frac{1}{T}\right) \right) & \text{si } \xi = 0 \ (\text{cas Gumbel})
\end{cases}
$$


```{python}
T_choice=10 # P√©riode de retour
par_X_annees=10
year_display_min = config["years"]["min"]
year_display_max = config["years"]["max"]


def carte_retour(model_name, echelle, season_choice, model_title, half):
    title = f"Changement du niveau de retour {T_choice} ans par {par_X_annees} ans du mod√®le {model_title}"
    result_gev = pipeline_data_gev_quarto(
        config=config,
        model_name=model_name,
        echelle=echelle,
        season_choice=season_choice,
        T_choice=T_choice,
        par_X_annees=par_X_annees,
        min_year=year_display_min,
        max_year=year_display_max
    )
    # Ex√©cution pipeline pour la moiti√© choisie
    html_map, _, r2, me, n, percent = pipeline_quarto_gev_half_france(
        model_name=model_name,
        season_choice=season_choice,
        echelle=echelle,
        par_X_annees=par_X_annees,
        result=result_gev,
        half=half,
        height=600
    )
    pipeline_total_title_map_legend_scatter_delta(
        title=title,
        year_min=config["years"]["min"],
        year_max=config["years"]["max"],
        echelle=echelle,
        season_choice=season_choice,
        html_map_legend=html_map,
        html_scatter=None
    )
```

---

```{python}
model_name="best_model"
echelle="quotidien"
season_choice = "djf"
model_title="minimisant l'AIC"
half = "sud"  # ou "nord"
carte_retour(model_name, echelle, season_choice, model_title, half)
```

---

```{python}
model_name="ns_gev_m3"
echelle="quotidien"
season_choice = "djf"
model_title="M‚ÇÉ‚ãÜ(Œº, œÉ)" # M ‚ÇÄ, ‚ÇÅ,‚ÇÇ, ‚ÇÉ, ‚ãÜ
half = "sud"  # ou "nord"
carte_retour(model_name, echelle, season_choice, model_title, half)
```

---

```{python}
model_name="best_model"
echelle="quotidien"
season_choice = "mam"
model_title="minimisant l'AIC"
half = "sud"  # ou "nord"
carte_retour(model_name, echelle, season_choice, model_title, half)
```

---

```{python}
model_name="ns_gev_m3"
echelle="quotidien"
season_choice = "mam"
model_title="M‚ÇÉ‚ãÜ(Œº, œÉ)" # M ‚ÇÄ, ‚ÇÅ,‚ÇÇ, ‚ÇÉ, ‚ãÜ
half = "sud"  # ou "nord"
carte_retour(model_name, echelle, season_choice, model_title, half)
```

---

```{python}
model_name="best_model"
echelle="quotidien"
season_choice = "jja"
model_title="minimisant l'AIC"
half = "sud"  # ou "nord"
carte_retour(model_name, echelle, season_choice, model_title, half)
```

---

```{python}
model_name="ns_gev_m3"
echelle="quotidien"
season_choice = "jja"
model_title="M‚ÇÉ‚ãÜ(Œº, œÉ)" # M ‚ÇÄ, ‚ÇÅ,‚ÇÇ, ‚ÇÉ, ‚ãÜ
half = "sud"  # ou "nord"
carte_retour(model_name, echelle, season_choice, model_title, half)
```

---

```{python}
model_name="best_model"
echelle="quotidien"
season_choice = "son"
model_title="minimisant l'AIC"
half = "sud"  # ou "nord"
carte_retour(model_name, echelle, season_choice, model_title, half)
```

---

```{python}
model_name="ns_gev_m3"
echelle="quotidien"
season_choice = "son"
model_title="M‚ÇÉ‚ãÜ(Œº, œÉ)" # M ‚ÇÄ, ‚ÇÅ,‚ÇÇ, ‚ÇÉ, ‚ãÜ
half = "sud"  # ou "nord"
carte_retour(model_name, echelle, season_choice, model_title, half)
```