---
title: "Caractérisation et évolution des précipitations extrêmes horaires en France à partir d’un modèle régional de climat à convection profonde résolue"

lang: fr
bibliography: bibliography.bib

format:
  pdf:
    documentclass: article
    papersize: a4
    fontsize: 11pt
    number-sections: true
    toc: false

execute:
  eval: true
  echo: false
  warning: false
  error: false

header-includes:
  - \usepackage{graphicx}
  - \usepackage{tabularx}
  - \usepackage{multirow}
  - \usepackage{geometry}
---

```{python}
from __future__ import annotations

import sys
import os
from pathlib import Path
from typing import Tuple

import pandas as pd

from svgutils.transform import fromfile, SVGFigure
import cairosvg

def _to_px(value: str | None) -> float:
    """
    Convertit une longueur SVG (px, mm, cm, pt, in) en pixels (float).

    Si `value` est None ou vide, retourne 0.
    """
    if not value:
        return 0.0
    value = value.strip()
    num = ''
    unit = ''
    for ch in value:
        if ch.isdigit() or ch in '.-':
            num += ch
        else:
            unit += ch
    if not num:
        return 0.0
    numf = float(num)
    unit = unit.strip().lower()
    if unit in ('', 'px'):
        return numf
    if unit == 'mm':
        return numf * 3.779527559055  # 96 dpi
    if unit == 'cm':
        return numf * 37.79527559055
    if unit == 'in':
        return numf * 96
    if unit == 'pt':
        return numf * 1.3333333333333  # 1 pt = 1/72 in
    # Fallback: assume pixels
    return numf


def _dims(fig) -> Tuple[float, float]:
    """
    Renvoie (width, height) de `fig` en pixels.

    1) viewBox (les 2 derniers termes)
    2) attributs width/height de la racine
    3) fig.get_size()
    """
    root = fig.root  # Correction ici : on accède à la balise <svg>
    viewbox = root.get('viewBox')
    if viewbox:
        parts = [p for p in viewbox.replace(',', ' ').split() if p]
        if len(parts) == 4:
            return float(parts[2]), float(parts[3])

    # attributs width/height sur la balise <svg>
    w_attr = root.get('width')
    h_attr = root.get('height')
    if w_attr and h_attr:
        return _to_px(w_attr), _to_px(h_attr)

    # fallback
    w, h = fig.get_size()
    return _to_px(w), _to_px(h)



def assemble_vertical(arome: Path, stations: Path, legend: Path, output: Path) -> None:
    # Charger les 3 SVG
    fig_arome = fromfile(str(arome))
    fig_stations = fromfile(str(stations))
    fig_legend = fromfile(str(legend))

    # Dimensions
    w_arome, h_arome = _dims(fig_arome)
    w_stations, h_stations = _dims(fig_stations)
    w_leg, h_leg = _dims(fig_legend)

    # Canvas global
    w_maps = max(w_arome, w_stations)
    h_maps = h_arome + h_stations
    height = h_maps  # somme des deux cartes

    # Facteur d'échelle pour que la légende fasse 1.5 fois la hauteur de la carte AROME
    scale_leg = (1.5 * h_arome) / h_leg
    w_leg_scaled = w_leg * scale_leg
    h_leg_scaled = h_leg * scale_leg  # = 1.5 * h_arome

    width = w_maps + w_leg_scaled  # légende à droite

    canvas = SVGFigure(f"{width}px", f"{height}px")
    canvas.root.set('viewBox', f"0 0 {width} {height}")

    # Racines
    root_arome = fig_arome.getroot()
    root_stations = fig_stations.getroot()
    root_legend = fig_legend.getroot()

    # Redimensionnement de la légende
    root_legend.scale(scale_leg, scale_leg)

    # Positionnement
    root_stations.moveto(0, h_arome)
    # Centrage vertical de la légende sur la hauteur totale
    y_leg = (h_maps - h_leg_scaled) / 2
    root_legend.moveto(w_maps, y_leg)

    canvas.append([root_arome, root_stations, root_legend])

    os.makedirs(os.path.dirname(str(output)), exist_ok=True)
    canvas.save(str(output))
    pdf_path = str(output)[:-4] + ".pdf"
    cairosvg.svg2pdf(url=str(output), write_to=pdf_path)
    return str(output)


def assemble(arome: Path, stations: Path, legend: Path, output: Path) -> str:
    # Charger les 2 cartes
    fig_arome = fromfile(str(arome))
    fig_stations = fromfile(str(stations))

    # Dimensions via _dims existant
    w_a, h_a = _dims(fig_arome)
    w_s, h_s = _dims(fig_stations)

    # Mise à l'échelle: même hauteur que AROME
    scale_s = h_a / h_s if h_s != 0 else 1.0
    root_a = fig_arome.getroot()
    root_s = fig_stations.getroot()
    root_s.scale(scale_s)

    w_s_scaled, h_s_scaled = w_s * scale_s, h_s * scale_s

    # Canvas côte à côte
    width  = w_a + w_s_scaled
    height = max(h_a, h_s_scaled)

    canvas = SVGFigure(f"{width}px", f"{height}px")
    canvas.root.set("viewBox", f"0 0 {width} {height}")

    # Positionnement: AROME à gauche, Stations à droite
    root_a.moveto(0, 0)
    root_s.moveto(w_a, 0)

    # Pas de légende
    canvas.append([root_a, root_s])

    os.makedirs(os.path.dirname(str(output)), exist_ok=True)
    canvas.save(str(output))
    cairosvg.svg2pdf(url=str(output), write_to=str(output)[:-4] + ".pdf")
    return str(output)

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.ticker as mticker

def combined_metrics_df(name_file: str):
    base_dir = Path("../outputs")         # dossier racine à explorer
    csv_paths = list(base_dir.rglob(name_file))

    frames = []
    for path in csv_paths:
        try:
            df = pd.read_csv(path)
            df["source"] = str(path.relative_to(base_dir))  # garder la provenance
            frames.append(df)
        except Exception as exc:                             # CSV illisible
            print(f"⚠️  Fichier ignoré {path}: {exc}")

    if not frames:
        raise SystemExit("Aucun metrics.csv trouvé !")

    # Concaténation puis export
    combined = pd.concat(frames, ignore_index=True)

    # --- harmonisation des échelles ---
    # cas quotidien_reduce
    mask_q = combined["source"].str.contains("quotidien_reduce", na=False)
    combined.loc[mask_q & (combined["echelle"] == "quotidien"), "echelle"] = "quotidien_reduce"

    # cas horaire_reduce
    mask_h = combined["source"].str.contains("horaire_reduce", na=False)
    combined.loc[mask_h & (combined["echelle"] == "horaire"), "echelle"] = "horaire_reduce"

    return combined

combined = combined_metrics_df("metrics.csv")
combined_signif = combined_metrics_df("metrics_signif.csv")
combined_signif["col_calculate"] = combined_signif["col_calculate"].astype(str) + "_signif"
combined_all = pd.concat([combined, combined_signif], ignore_index=True)


import math
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.ticker as mticker


def plot_r_by_season(
    df,
    echelles,
    col_values,          # <-- plusieurs indicateurs (ex. ['numday', 'mean', 'mean-max'])
    nom_fichier,         # préfixe du fichier (le numéro du facet est ajouté automatiquement)
    col_plot: str="r"
):
    """
    Trace un bar‑chart groupé « r » par saison, pour plusieurs indicateurs.
    Produit un seul PNG contenant un facet‑grid (nrows × ncols).

    Parameters
    ----------
    df : pandas.DataFrame
    echelles : list[str]
        Sous-ensemble d'échelles à garder (ex. ['quotidien', 'horaire'])
    col_values : list[str]
        Liste des valeurs cibles de la colonne 'col_calculate'
    nom_fichier : str
        Nom de base du fichier PNG (sans extension)
    """
    ncols=len(col_values)

    label_map = {
        "numday":  "Nombre de jour de pluie",
        "mean":    "Cumul de précipitations",
        "mean-max": "Moyenne des maxima",
        "z_T_p":   "Tendance significative et non significative",
        "z_T_p_signif":   "Tendance significative"
    }

    # ---------------------------------------------
    # 0) Préparation de la grille de sous‑graphes
    # ---------------------------------------------
    n_facets = len(col_values)
    ncols = max(1, min(ncols, n_facets))
    nrows = math.ceil(n_facets / ncols)

    fig, axes = plt.subplots(
        nrows=nrows,
        ncols=ncols,
        figsize=(12, 5 * nrows),
        sharey=True
    )
    # axes → tableau 1D pour itération uniforme
    axes = np.atleast_1d(axes).flatten()

    # Pour récupérer une seule fois handles/labels de la légende
    first_handles, first_labels = None, None

    # ------------------------------------------------------------------
    # Boucle sur chaque col_value demandé → un subplot par indicateur
    # ------------------------------------------------------------------
    for ax, col_value in zip(axes, col_values):
        # --- 1) Filtrage identique ---
        sub = df.loc[
            (df["echelle"].isin(echelles)) &
            (df["col_calculate"] == col_value),
            ["season", "echelle", col_plot]
        ]
        if sub.empty:
            ax.set_visible(False)
            ax.set_title(f"Aucune donnée pour '{col_value}'")
            continue

        sub["season"] = sub["season"].str.upper()

        # --- 2) Ordre fixe ---
        ordre_total = [
            "HYDRO", 
            "SON", "DJF", "MAM", "JJA",
            "OND", "JFM", "AMJ", "JAS",
            "SEP", "OCT", "NOV", "DEC", "JAN", "FEV", 
            "MAR", "AVR", "MAI", "JUI", "JUILL", "AOU"
        ]
        saisons_pres = [s for s in ordre_total if s in sub["season"].unique()]

        # --- 3) Renommage des échelles ---
        rename_map = {
            "quotidien":        "Journalière (1959‑2022)",
            "quotidien_reduce": "Journalière (1990‑2022)",
            "horaire":          "Horaire (1990‑2022)",
        }

        # --- 4) Pivot ---
        pivot = (
            sub.pivot(index="season", columns="echelle", values=col_plot)
               .rename(columns=rename_map)
               .reindex(saisons_pres)
        )

        # --- 5) Colonnes dans l’ordre demandé ---
        ordre_cols = [
            rename_map[k] for k in ["quotidien", "quotidien_reduce", "horaire"]
            if rename_map[k] in pivot.columns
        ]
        pivot = pivot[ordre_cols]

        # --- 6) Couleurs ---
        couleurs = ["black", "dimgray", "lightgray"][:pivot.shape[1]]

        # --- 7) Bar chart groupé ---
        x = np.arange(len(pivot))
        largeur = 0.8 / pivot.shape[1]

        for i, (col, couleur) in enumerate(zip(pivot.columns, couleurs)):

            bars = ax.bar(
                x + i * largeur,
                pivot[col],
                width=largeur,
                color=couleur,
                label=col
            )

        # --- 8) Axes, grille, ticks ---
        ax.set_xticks(
            x + largeur * (pivot.shape[1] - 1) / 2,
            pivot.index
        )
        ax.tick_params(axis='x', rotation=45)   # Rotation ici
        ax.set_xlabel("")
        if col_plot=="me":
          ax.set_ylabel("Δ (AROME - Stations) (mm/h)")
        else:
          ax.set_ylabel(col_plot)
        ax.set_title(label_map.get(col_value, col_value))   # titre lisible pour chaque subplot)

        if col_plot=="r":
          ax.set_ylim(top=1)   # <-- Forcer ymax à 1
          ax.yaxis.set_major_locator(mticker.MultipleLocator(0.1))
          ax.yaxis.set_minor_locator(mticker.MultipleLocator(0.02))
        else:
          ax.yaxis.set_major_locator(mticker.MultipleLocator(0.5))
          ax.yaxis.set_minor_locator(mticker.MultipleLocator(0.25))

        ax.grid(axis="y", which="major", linestyle="--", alpha=0.8)
        ax.grid(axis="y", which="minor", linestyle=":",  alpha=0.5)

        # mémoriser les handles/labels la première fois
        if first_handles is None:
            first_handles, first_labels = ax.get_legend_handles_labels()

        # supprimer la légende locale seulement si elle existe
        leg = ax.get_legend()
        if leg is not None:
            leg.remove()


    # ------------------------------------------------------------------
    # 9) Légende globale (ligne en‑haut, centrée)
    # ------------------------------------------------------------------
    if first_handles:
        fig.legend(
            first_handles,
            first_labels,
            loc="lower center",
            ncol=len(first_labels),
            bbox_to_anchor=(0.5, 1.02)
        )

    fig.tight_layout()
    fig.subplots_adjust(top=0.90)  # laisser de l’espace pour la légende globale

    # ------------------------------------------------------------------
    # 10) Sauvegarde
    # ------------------------------------------------------------------
    fig.savefig(f"figures/{nom_fichier}.png", dpi=500, bbox_inches="tight")
    plt.close(fig)


def assemble_un(carte: Path, legend: Path, output: Path) -> str:
    """
    Assemble une carte SVG et sa légende à droite.
    La légende est mise à l'échelle pour avoir exactement la même hauteur que la carte.
    Exporte aussi un PDF à côté du SVG.
    """
    # Charger les SVG
    fig_map = fromfile(str(carte))
    fig_leg = fromfile(str(legend))

    # Dimensions (en px)
    w_map, h_map = _dims(fig_map)
    w_leg, h_leg = _dims(fig_leg)
    if h_map == 0 or h_leg == 0:
        raise ValueError("Hauteur nulle détectée dans la carte ou la légende.")

    # Mise à l'échelle de la légende pour égaler la hauteur de la carte
    scale_leg = h_map / h_leg
    w_leg_scaled = w_leg * scale_leg
    h_leg_scaled = h_leg * scale_leg  # = h_map

    # Canvas final
    width  = w_map + w_leg_scaled
    height = h_map
    canvas = SVGFigure(f"{width}px", f"{height}px")
    canvas.root.set("viewBox", f"0 0 {width} {height}")

    # Racines et transformations
    root_map = fig_map.getroot()
    root_leg = fig_leg.getroot()
    root_leg.scale(scale_leg, scale_leg)

    # Positionnement
    root_map.moveto(0, 0)
    # Centrage vertical robuste en cas d'arrondis
    y_leg = max(0, (h_map - h_leg_scaled) / 2.0)
    root_leg.moveto(w_map, y_leg)

    # Assemblage
    canvas.append([root_map, root_leg])

    # Sauvegardes
    os.makedirs(os.path.dirname(str(output)), exist_ok=True)
    canvas.save(str(output))
    cairosvg.svg2pdf(url=str(output), write_to=str(output)[:-4] + ".pdf")
    return str(output)

```



\newpage
<!-- FIGURE 1 -->
```{=latex}
\newlength{\SavedTextWidthA}
\setlength{\SavedTextWidthA}{\textwidth}

\begingroup
\newgeometry{left=0.1cm,right=0.1cm}

\noindent
\begin{minipage}[t]{\paperwidth}
\centering
\setlength{\tabcolsep}{0pt}%
\renewcommand{\arraystretch}{1}%

\begin{tabular}{>{\centering\arraybackslash}p{.49\paperwidth}
                >{\centering\arraybackslash}p{.49\paperwidth}}
\includegraphics[width=\linewidth]{../outputs/hist/dispo/quotidien/hydro/hist_len_years_cum.pdf} &
\includegraphics[width=\linewidth]{../outputs/hist/dispo/horaire/hydro/hist_len_years_cum.pdf} \\[-0.5mm]

\small Stations at daily time step (n = 8198) &
\small Stations at hourly time step (n = 2315)
\end{tabular}

\medskip
\captionsetup{type=figure}%
\hspace*{\fill}%
\begin{minipage}{\SavedTextWidthA}
  \captionof{figure}{\small Distribution of the number of hydrological years with at most 10\% missing values for Météo-France stations at the daily (1959-2022) and hourly (1990-2022) time steps.}
\end{minipage}%
\hspace*{\fill}%

\end{minipage}
\restoregeometry
\endgroup
```

\newpage
<!-- FIGURE 2 -->

```{=latex}
\newlength{\SavedTextWidthB}
\setlength{\SavedTextWidthB}{\textwidth}

\begingroup
\newgeometry{left=0.1cm,right=0.1cm}

\noindent
\begin{minipage}[t]{\paperwidth}
\centering
\includegraphics[width=.5\SavedTextWidthB]{figures/espace_definition.pdf}

\medskip
\captionsetup{type=figure}%
\hspace*{\fill}%
\begin{minipage}{\SavedTextWidthB}
  \captionof{figure}{\small Mapping of the computational domain of the AROME numerical model.}
\end{minipage}%
\hspace*{\fill}%

\end{minipage}
\restoregeometry
\endgroup
```



\newpage
<!-- FIGURE 3 -->

```{python}
jour_pluie = assemble_vertical(
  "../outputs/maps/stats_numday/quotidien/compare_1/sat_99.9/hydro/mod_norast.svg",
  "../outputs/maps/stats_numday/quotidien/compare_1/sat_99.9/hydro/obs_norast.svg",
  "../outputs/maps/stats_numday/quotidien/compare_1/sat_99.9/legend.svg",
  "figures/jour_pluie.svg"
)
df_jour_pluie = combined.loc[(combined["echelle"] == "quotidien") & (combined["season"] == "hydro") & (combined["col_calculate"] == "numday"), ["n", "r", "me", "delta"]]

mean_pluie_jour = assemble_vertical(
  "../outputs/maps/stats_mean/quotidien/compare_1/sat_99.0/hydro/mod_norast.svg",
  "../outputs/maps/stats_mean/quotidien/compare_1/sat_99.0/hydro/obs_norast.svg",
  "../outputs/maps/stats_mean/quotidien/compare_1/sat_99.0/legend.svg",
  "figures/mean_pluie_jour.svg"
)
df_mean_pluie_jour = combined.loc[(combined["echelle"] == "quotidien") & (combined["season"] == "hydro") & (combined["col_calculate"] == "mean"), ["n", "r", "me", "delta"]]


mean_max_pluie_jour = assemble_vertical(
  "../outputs/maps/stats_mean-max/quotidien/compare_9/sat_99.0/hydro/mod_norast.svg",
  "../outputs/maps/stats_mean-max/quotidien/compare_9/sat_99.0/hydro/obs_norast.svg",
  "../outputs/maps/stats_mean-max/quotidien/compare_9/sat_99.0/legend.svg",
  "figures/mean-max_pluie_jour.svg"
)
df_mean_max_pluie_jour = combined.loc[(combined["echelle"] == "quotidien") & (combined["season"] == "hydro") & (combined["col_calculate"] == "mean-max"), ["n", "r", "me", "delta"]]

mean_max_pluie_horaire = assemble_vertical(
  "../outputs/maps/stats_mean-max/horaire/compare_9/sat_99.0/hydro/mod_norast.svg",
  "../outputs/maps/stats_mean-max/horaire/compare_9/sat_99.0/hydro/obs_norast.svg",
  "../outputs/maps/stats_mean-max/horaire/compare_9/sat_99.0/legend.svg",
  "figures/mean-max_pluie_horaire.svg"
)

df_mean_max_pluie_horaire = combined.loc[(combined["echelle"] == "horaire") & (combined["season"] == "hydro") & (combined["col_calculate"] == "mean-max"), ["n", "r", "me", "delta"]]

df_mean_max_pluie_horaire_jja = combined.loc[(combined["echelle"] == "horaire") & (combined["season"] == "jja") & (combined["col_calculate"] == "mean-max"), ["n", "r", "me", "delta"]]

jour_pluie_diff = assemble_un(
  "../outputs/maps/stats_numday/quotidien/compare_1/sat_99.9/hydro/obs_norast_diff.svg",
  "../outputs/maps/stats_numday/quotidien/compare_1/sat_99.9/legend_diff.svg",
  "figures/jour_pluie_diff.svg"
)

mean_pluie_jour_diff = assemble_un(
  "../outputs/maps/stats_mean/quotidien/compare_1/sat_99.0/hydro/obs_norast_diff.svg",
  "../outputs/maps/stats_mean/quotidien/compare_1/sat_99.0/legend_diff.svg",
  "figures/mean_pluie_jour_diff.svg"
)

mean_max_pluie_jour_diff = assemble_un(
  "../outputs/maps/stats_mean-max/quotidien/compare_9/sat_99.0/hydro/obs_norast_diff.svg",
  "../outputs/maps/stats_mean-max/quotidien/compare_9/sat_99.0/legend_diff.svg",
  "figures/mean-max_pluie_jour_diff.svg"
)

mean_max_pluie_horaire_diff = assemble_un(
  "../outputs/maps/stats_mean-max/horaire/compare_9/sat_99.0/hydro/obs_norast_diff.svg",
  "../outputs/maps/stats_mean-max/horaire/compare_9/sat_99.0/legend_diff.svg",
  "figures/mean-max_pluie_horaire_diff.svg"
)
```



```{=latex}
\newlength{\SavedTextWidthC}
\setlength{\SavedTextWidthC}{\textwidth}

\begingroup
\providecommand{\+}{+}% neutralise \+ localement
\renewcommand{\.}{.}% neutralise \. localement

\newgeometry{left=0.1cm,right=0.1cm}

\noindent
\begin{minipage}[t]{\paperwidth}
\centering
\setlength{\tabcolsep}{0pt}%
\renewcommand{\arraystretch}{1}%

\begin{tabular}{>{\centering\arraybackslash}p{.24\paperwidth}
                >{\centering\arraybackslash}p{.24\paperwidth}
                >{\centering\arraybackslash}p{.24\paperwidth}
                >{\centering\arraybackslash}p{.24\paperwidth}}
\small\bfseries \shortstack{Number of days\\ per year\\ with precipitation} &
\small\bfseries \shortstack{Annual\\ precipitation\\ total} &
\small\bfseries \shortstack{Mean of daily\\ precipitation\\ maxima} &
\small\bfseries \shortstack{Mean of hourly\\ precipitation\\ maxima} \\[-0.5mm]

\small $r =$ `{python} f'{df_jour_pluie["r"].iloc[0].item():.2f}'` (n = `{python} f'{df_jour_pluie["n"].iloc[0].item()}'`) &
\small $r =$ `{python} f'{df_mean_pluie_jour["r"].iloc[0].item():.2f}'` (n = `{python} f'{df_mean_pluie_jour["n"].iloc[0].item()}'`) &
\small $r =$ `{python} f'{df_mean_max_pluie_jour["r"].iloc[0].item():.2f}'` (n = `{python} f'{df_mean_max_pluie_jour["n"].iloc[0].item()}'`) &
\small $r =$ `{python} f'{df_mean_max_pluie_horaire["r"].iloc[0].item():.2f}'` (n = `{python} f'{df_mean_max_pluie_horaire["n"].iloc[0].item()}'`) \\[-0.5mm]

\includegraphics[width=\linewidth]{figures/jour_pluie.pdf} &
\includegraphics[width=\linewidth]{figures/mean_pluie_jour.pdf} &
\includegraphics[width=\linewidth]{figures/mean-max_pluie_jour.pdf} &
\includegraphics[width=\linewidth]{figures/mean-max_pluie_horaire.pdf} \\[-0.5mm]

\small $ME = `{python} f'{df_jour_pluie["me"].iloc[0].item():+.2f}'`\,\mathrm{j}\,(`{python} f'{df_jour_pluie["delta"].iloc[0].item():+.2f}'`\%)$ &
\small $ME = `{python} f'{df_mean_pluie_jour["me"].iloc[0].item():+.2f}'`\,\mathrm{mm/yr}\,(`{python} f'{df_mean_pluie_jour["delta"].iloc[0].item():+.2f}'`\%)$ &
\small $ME = `{python} f'{df_mean_max_pluie_jour["me"].iloc[0].item():+.2f}'`\,\mathrm{mm/day}\,(`{python} f'{df_mean_max_pluie_jour["delta"].iloc[0].item():+.2f}'`\%)$ &
\small $ME = `{python} f'{df_mean_max_pluie_horaire["me"].iloc[0].item():+.2f}'`\,\mathrm{mm/h}\,(`{python} f'{df_mean_max_pluie_horaire["delta"].iloc[0].item():+.2f}'`\%)$\\[-0.5mm]

\includegraphics[width=\linewidth]{figures/jour_pluie_diff.pdf} &
\includegraphics[width=\linewidth]{figures/mean_pluie_jour_diff.pdf} &
\includegraphics[width=\linewidth]{figures/mean-max_pluie_jour_diff.pdf} &
\includegraphics[width=\linewidth]{figures/mean-max_pluie_horaire_diff.pdf}
\end{tabular}

\bigskip
\captionsetup{type=figure}%
\noindent\makebox[\paperwidth][c]{%
  \parbox{\SavedTextWidthC}{%
    \captionof{figure}{\small Climatology between the AROME model (first row), Météo-France stations (second row) with the correlation ($r$) and the number of stations compared (n), and the AROME–Station difference (third row) with the bias ($ME$) and the associated relative deviation (\%) derived from daily data from 1959 to 2022 and hourly data from 1990 to 2022 for a hydrological year.}%
  }%
}

\end{minipage}
\restoregeometry
\endgroup
```

\newpage
<!-- FIGURE 4 -->

```{python} 
plot_r_by_season(combined, echelles=['quotidien', 'quotidien_reduce', 'horaire'], col_values=['numday', 'mean', 'mean-max'], nom_fichier="histo_numday_mean_mean-max")
```

```{=latex}
\newlength{\SavedTextWidthD}
\setlength{\SavedTextWidthD}{\textwidth}

\begingroup
\newgeometry{left=0.1cm,right=0.1cm}

\noindent
\begin{minipage}[t]{\paperwidth}
\centering
\includegraphics[width=\SavedTextWidthD]{figures/histo_numday_mean_mean-max.png}

\medskip
\captionsetup{type=figure}%
\hspace*{\fill}%
\begin{minipage}{\SavedTextWidthD}
  \captionof{figure}{\small Correlations of climatological data between the AROME model and Météo-France stations for each data source.}
\end{minipage}%
\hspace*{\fill}%

\end{minipage}
\restoregeometry
\endgroup
```

\newpage
<!-- FIGURE 5 -->

```{python}
trend_pluie_hydro = assemble(
  "../outputs/maps/gev_z_T_p/quotidien/compare_9/sat_99.0/hydro/mod_signif_norast.svg",
  "../outputs/maps/gev_z_T_p/quotidien/compare_9/sat_99.0/hydro/obs_signif_norast.svg",
  "../outputs/maps/gev_z_T_p/quotidien/compare_9/sat_99.0/legend_signif.svg",
  "figures/trend_pluie_hydro.svg"
)
df_trend_pluie_hydro = combined_all.loc[(combined_all["echelle"] == "quotidien") & (combined_all["season"] == "hydro") & (combined_all["col_calculate"] == "z_T_p_signif"), ["n", "r", "me", "delta"]]

trend_pluie_ond = assemble(
  "../outputs/maps/gev_z_T_p/quotidien/compare_9/sat_99.0/ond/mod_signif_norast.svg",
  "../outputs/maps/gev_z_T_p/quotidien/compare_9/sat_99.0/ond/obs_signif_norast.svg",
  "../outputs/maps/gev_z_T_p/quotidien/compare_9/sat_99.0/legend_signif.svg",
  "figures/trend_pluie_ond.svg"
)
df_trend_pluie_ond = combined_all.loc[(combined_all["echelle"] == "quotidien") & (combined_all["season"] == "ond") & (combined_all["col_calculate"] == "z_T_p_signif"), ["n", "r", "me", "delta"]]

trend_pluie_jfm = assemble(
  "../outputs/maps/gev_z_T_p/quotidien/compare_9/sat_99.0/jfm/mod_signif_norast.svg",
  "../outputs/maps/gev_z_T_p/quotidien/compare_9/sat_99.0/jfm/obs_signif_norast.svg",
  "../outputs/maps/gev_z_T_p/quotidien/compare_9/sat_99.0/legend_signif.svg",
  "figures/trend_pluie_jfm.svg"
)
df_trend_pluie_jfm = combined_all.loc[(combined_all["echelle"] == "quotidien") & (combined_all["season"] == "jfm") & (combined_all["col_calculate"] == "z_T_p_signif"), ["n", "r", "me", "delta"]]

trend_pluie_amj = assemble(
  "../outputs/maps/gev_z_T_p/quotidien/compare_9/sat_99.0/amj/mod_signif_norast.svg",
  "../outputs/maps/gev_z_T_p/quotidien/compare_9/sat_99.0/amj/obs_signif_norast.svg",
  "../outputs/maps/gev_z_T_p/quotidien/compare_9/sat_99.0/legend_signif.svg",
  "figures/trend_pluie_amj.svg"
)
df_trend_pluie_amj = combined_all.loc[(combined_all["echelle"] == "quotidien") & (combined_all["season"] == "amj") & (combined_all["col_calculate"] == "z_T_p_signif"), ["n", "r", "me", "delta"]]

trend_pluie_jas = assemble(
  "../outputs/maps/gev_z_T_p/quotidien/compare_9/sat_99.0/jas/mod_signif_norast.svg",
  "../outputs/maps/gev_z_T_p/quotidien/compare_9/sat_99.0/jas/obs_signif_norast.svg",
  "../outputs/maps/gev_z_T_p/quotidien/compare_9/sat_99.0/legend_signif.svg",
  "figures/trend_pluie_jas.svg"
)
df_trend_pluie_jas = combined_all.loc[(combined_all["echelle"] == "quotidien") & (combined_all["season"] == "jas") & (combined_all["col_calculate"] == "z_T_p_signif"), ["n", "r", "me", "delta"]]
```



```{=latex}
\begingroup
\providecommand{\+}{+}% neutralise \+ localement
\renewcommand{\.}{.}% neutralise \. localement

% ---- Grille principale en pleine largeur (outrepasse les marges) ----
% On réduit temporairement les marges à 0.1 cm pour cette figure uniquement
\newgeometry{left=0.1cm,right=0.1cm}

\begin{center}
\noindent
\begin{minipage}[t]{\paperwidth}
  % Aucun espacement interne
  \setlength{\tabcolsep}{0pt}      % marge horizontale nulle entre colonnes
  \renewcommand{\arraystretch}{1}  % pas d’espacement vertical supplémentaire
  \begin{tabularx}{\paperwidth}{
    >{\centering\arraybackslash}m{0.49\paperwidth}
    >{\centering\arraybackslash}m{0.49\paperwidth}
  }

    % --- Ligne 1 ---
    \textbf{\small OND} & \textbf{\small JFM} \\[-0.5mm]
    \small $r =$ {`{python} f'{df_trend_pluie_ond['r'].iloc[0].item():.2f}'`} (n={`{python} f'{df_trend_pluie_ond['n'].iloc[0].item()}'`}) &
    \small $r =$ {`{python} f'{df_trend_pluie_jfm['r'].iloc[0].item():.2f}'`} (n={`{python} f'{df_trend_pluie_jfm['n'].iloc[0].item()}'`}) \\[-0.5mm]
    \small $ME =$ {`{python} f'{df_trend_pluie_ond['me'].iloc[0].item():+.2f}'`}\% &
    \small $ME =$ {`{python} f'{df_trend_pluie_jfm['me'].iloc[0].item():+.2f}'`}\% \\[-0.5mm]
    \includegraphics[width=\linewidth]{figures/trend_pluie_ond.pdf} &
    \includegraphics[width=\linewidth]{figures/trend_pluie_jfm.pdf} \\

    % --- Ligne 2 ---
    \textbf{\small AMJ} & \textbf{\small JAS} \\[-0.5mm]
    \small $r =$ {`{python} f'{df_trend_pluie_amj['r'].iloc[0].item():.2f}'`} (n={`{python} f'{df_trend_pluie_amj['n'].iloc[0].item()}'`}) &
    \small $r =$ {`{python} f'{df_trend_pluie_jas['r'].iloc[0].item():.2f}'`} (n={`{python} f'{df_trend_pluie_jas['n'].iloc[0].item()}'`}) \\[-0.5mm]
    \small $ME =$ {`{python} f'{df_trend_pluie_amj['me'].iloc[0].item():+.2f}'`}\% &
    \small $ME =$ {`{python} f'{df_trend_pluie_jas['me'].iloc[0].item():+.2f}'`}\% \\[-0.5mm]
    \includegraphics[width=\linewidth]{figures/trend_pluie_amj.pdf} &
    \includegraphics[width=\linewidth]{figures/trend_pluie_jas.pdf} \\

    % --- Ligne 3 ---
    \textbf{\small HYDRO} &
    \multirow{3}{*}{
    \begin{minipage}[c]{\linewidth}
        \centering
        % Légende pivotée : aligne verticalement avec HYDRO, r=, ME=
        \includegraphics[width=0.85\linewidth,keepaspectratio]{../outputs/maps/gev_z_T_p/quotidien/compare_9/sat_99.0/legend_horiz_signif.pdf}
        \makebox[0.85\linewidth][c]{\small \%}
    \end{minipage}
    }
    \\[-0.5mm]

    \small $r =$ {`{python} f'{df_trend_pluie_hydro['r'].iloc[0].item():.2f}'`} (n={`{python} f'{df_trend_pluie_hydro['n'].iloc[0].item()}'`}) & \\[-0.5mm]
    \small $ME =$ {`{python} f'{df_trend_pluie_hydro['me'].iloc[0].item():+.2f}'`}\% & \\[-0.5mm]

    % --- ligne de la carte + caption (nouveau bloc) ---
    \includegraphics[width=\linewidth]{figures/trend_pluie_hydro.pdf} &
    \begin{minipage}[c]{\linewidth}
    \centering
    \vspace{0.5em}
    \begin{minipage}[c]{0.90\linewidth} % <-- crée une marge interne horizontale (~5% chaque côté)
        \setlength{\parindent}{0pt}
        \small
        \captionof{figure}{
        \vspace{0.3em}
        Seasonal analysis of relative trends from 1995 to 2022 (\%) in the 10-year return level
        between the AROME model (left) and Météo-France stations (right), with the correlation ($r$),
        the number of stations compared (n), and the bias ($ME$) derived from daily precipitation maxima
        from 1959 to 2022.
        \vspace{0.3em}
        }
    \end{minipage}
    \end{minipage}
    \\

    
  \end{tabularx}
\end{minipage}
\end{center}

\restoregeometry
\endgroup
```

\newpage
<!-- FIGURE 6 -->

```{python}
trend_horaire_pluie_hydro = assemble(
  "../outputs/maps/gev_z_T_p/horaire/compare_9/sat_90.0/hydro/mod_signif_norast.svg",
  "../outputs/maps/gev_z_T_p/horaire/compare_9/sat_90.0/hydro/obs_signif_norast.svg",
  "../outputs/maps/gev_z_T_p/horaire/compare_9/sat_90.0/legend_signif.svg",
  "figures/trend_horaire_pluie_hydro.svg"
)
df_trend_horaire_pluie_hydro = combined_all.loc[(combined_all["echelle"] == "horaire") & (combined_all["season"] == "hydro") & (combined_all["col_calculate"] == "z_T_p_signif"), ["n", "r", "me", "delta"]]

trend_horaire_pluie_ond = assemble(
  "../outputs/maps/gev_z_T_p/horaire/compare_9/sat_90.0/ond/mod_signif_norast.svg",
  "../outputs/maps/gev_z_T_p/horaire/compare_9/sat_90.0/ond/obs_signif_norast.svg",
  "../outputs/maps/gev_z_T_p/horaire/compare_9/sat_90.0/legend_signif.svg",
  "figures/trend_horaire_pluie_ond.svg"
)
df_trend_horaire_pluie_ond = combined_all.loc[(combined_all["echelle"] == "horaire") & (combined_all["season"] == "ond") & (combined_all["col_calculate"] == "z_T_p_signif"), ["n", "r", "me", "delta"]]

trend_horaire_pluie_jfm = assemble(
  "../outputs/maps/gev_z_T_p/horaire/compare_9/sat_90.0/jfm/mod_signif_norast.svg",
  "../outputs/maps/gev_z_T_p/horaire/compare_9/sat_90.0/jfm/obs_signif_norast.svg",
  "../outputs/maps/gev_z_T_p/horaire/compare_9/sat_90.0/legend_signif.svg",
  "figures/trend_horaire_pluie_jfm.svg"
)
df_trend_horaire_pluie_jfm = combined_all.loc[(combined_all["echelle"] == "horaire") & (combined_all["season"] == "jfm") & (combined_all["col_calculate"] == "z_T_p_signif"), ["n", "r", "me", "delta"]]

trend_horaire_pluie_amj = assemble(
  "../outputs/maps/gev_z_T_p/horaire/compare_9/sat_90.0/amj/mod_signif_norast.svg",
  "../outputs/maps/gev_z_T_p/horaire/compare_9/sat_90.0/amj/obs_signif_norast.svg",
  "../outputs/maps/gev_z_T_p/horaire/compare_9/sat_90.0/legend_signif.svg",
  "figures/trend_horaire_pluie_amj.svg"
)
df_trend_horaire_pluie_amj = combined_all.loc[(combined_all["echelle"] == "horaire") & (combined_all["season"] == "amj") & (combined_all["col_calculate"] == "z_T_p_signif"), ["n", "r", "me", "delta"]]

trend_horaire_pluie_jas = assemble(
  "../outputs/maps/gev_z_T_p/horaire/compare_9/sat_90.0/jas/mod_signif_norast.svg",
  "../outputs/maps/gev_z_T_p/horaire/compare_9/sat_90.0/jas/obs_signif_norast.svg",
  "../outputs/maps/gev_z_T_p/horaire/compare_9/sat_90.0/legend_signif.svg",
  "figures/trend_horaire_pluie_jas.svg"
)
df_trend_horaire_pluie_jas = combined_all.loc[(combined_all["echelle"] == "horaire") & (combined_all["season"] == "jas") & (combined_all["col_calculate"] == "z_T_p_signif"), ["n", "r", "me", "delta"]]
```

```{=latex}
\begingroup
\providecommand{\+}{+}
\renewcommand{\.}{.}

% Marges réduites pour la figure pleine largeur
\newgeometry{left=0.1cm,right=0.1cm}

\begin{center}
\noindent
\begin{minipage}[t]{\paperwidth}
  \setlength{\tabcolsep}{0pt}
  \renewcommand{\arraystretch}{1}
  \begin{tabularx}{\paperwidth}{
    >{\centering\arraybackslash}m{0.49\paperwidth}
    >{\centering\arraybackslash}m{0.49\paperwidth}
  }

    % --- Ligne 1 ---
    \textbf{\small OND} & \textbf{\small JFM} \\[-0.5mm]
    \small $r =$ {`{python} f'{df_trend_horaire_pluie_ond['r'].iloc[0].item():.2f}'`} (n={`{python} f'{df_trend_horaire_pluie_ond['n'].iloc[0].item()}'`}) &
    \small $r =$ {`{python} f'{df_trend_horaire_pluie_jfm['r'].iloc[0].item():.2f}'`} (n={`{python} f'{df_trend_horaire_pluie_jfm['n'].iloc[0].item()}'`}) \\[-0.5mm]
    \small $ME =$ {`{python} f'{df_trend_horaire_pluie_ond['me'].iloc[0].item():+.2f}'`}\% &
    \small $ME =$ {`{python} f'{df_trend_horaire_pluie_jfm['me'].iloc[0].item():+.2f}'`}\% \\[-0.5mm]
    \includegraphics[width=\linewidth]{figures/trend_horaire_pluie_ond.pdf} &
    \includegraphics[width=\linewidth]{figures/trend_horaire_pluie_jfm.pdf} \\

    % --- Ligne 2 ---
    \textbf{\small AMJ} & \textbf{\small JAS} \\[-0.5mm]
    \small $r =$ {`{python} f'{df_trend_horaire_pluie_amj['r'].iloc[0].item():.2f}'`} (n={`{python} f'{df_trend_horaire_pluie_amj['n'].iloc[0].item()}'`}) &
    \small $r =$ {`{python} f'{df_trend_horaire_pluie_jas['r'].iloc[0].item():.2f}'`} (n={`{python} f'{df_trend_horaire_pluie_jas['n'].iloc[0].item()}'`}) \\[-0.5mm]
    \small $ME =$ {`{python} f'{df_trend_horaire_pluie_amj['me'].iloc[0].item():+.2f}'`}\% &
    \small $ME =$ {`{python} f'{df_trend_horaire_pluie_jas['me'].iloc[0].item():+.2f}'`}\% \\[-0.5mm]
    \includegraphics[width=\linewidth]{figures/trend_horaire_pluie_amj.pdf} &
    \includegraphics[width=\linewidth]{figures/trend_horaire_pluie_jas.pdf} \\

    % --- Ligne 3 ---
    \textbf{\small HYDRO} &
    \multirow{3}{*}{
    \begin{minipage}[c]{\linewidth}
        \centering
        \includegraphics[width=0.85\linewidth,keepaspectratio]{../outputs/maps/gev_z_T_p/horaire/compare_9/sat_90.0/legend_horiz_signif.pdf}
        \makebox[0.85\linewidth][c]{\small \%}
    \end{minipage}
    }
    \\[-0.5mm]

    \small $r =$ {`{python} f'{df_trend_horaire_pluie_hydro['r'].iloc[0].item():.2f}'`} (n={`{python} f'{df_trend_horaire_pluie_hydro['n'].iloc[0].item()}'`}) & \\[-0.5mm]
    \small $ME =$ {`{python} f'{df_trend_horaire_pluie_hydro['me'].iloc[0].item():+.2f}'`}\% & \\[-0.5mm]

    % Carte + légende de figure
    \includegraphics[width=\linewidth]{figures/trend_horaire_pluie_hydro.pdf} &
    \begin{minipage}[c]{\linewidth}
    \centering
    \vspace{0.5em}
    \begin{minipage}[c]{0.90\linewidth}
        \setlength{\parindent}{0pt}
        \small
        \captionof{figure}{
        \vspace{0.3em}
        Seasonal analysis of relative trends from 1995 to 2022 (\%) in the 10-year return level
        between the AROME model (left) and Météo-France stations (right), with the correlation ($r$),
        the number of stations compared (n), and the bias ($ME$) derived from hourly precipitation maxima
        from 1990 to 2022.
        \vspace{0.3em}
        }
    \end{minipage}
    \end{minipage}
    \\

  \end{tabularx}
\end{minipage}
\end{center}

\restoregeometry
\endgroup
```


\newpage
<!-- FIGURE 7 -->

```{python} 
plot_r_by_season(combined_all , echelles=['quotidien', 'quotidien_reduce', 'horaire'], col_values=['z_T_p', 'z_T_p_signif'], nom_fichier="histo_z_T_p")
```

```{=latex}
\newlength{\SavedTextWidthG}
\setlength{\SavedTextWidthG}{\textwidth}

\begingroup
\newgeometry{left=0.1cm,right=0.1cm}

\noindent
\begin{minipage}[t]{\paperwidth}
\centering
\includegraphics[width=\SavedTextWidthG]{figures/histo_z_T_p.png}

\medskip
\captionsetup{type=figure}%
\hspace*{\fill}%
\begin{minipage}{\SavedTextWidthG}
  \captionof{figure}{\small Correlations of relative trends (all and significant) between AROME and Météo-France stations, by season and by month.}
\end{minipage}%
\hspace*{\fill}%

\end{minipage}
\restoregeometry
\endgroup
```