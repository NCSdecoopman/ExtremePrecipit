---
title: "Caractérisation et évolution des précipitations extrêmes horaires en France à partir d’un modèle régional de climat à convection profonde résolue"

lang: fr
bibliography: bibliography.bib

format:
  pdf:
    documentclass: article
    papersize: a4
    fontsize: 11pt
    number-sections: true
    toc: false

execute:
  eval: true
  echo: false
  warning: false
  error: false

header-includes:
  - \usepackage{graphicx}
  - \usepackage{tabularx}
  - \usepackage{multirow}
  - \usepackage{geometry}


---

```{python}
from __future__ import annotations

import sys
import os
from pathlib import Path
from typing import Tuple

import pandas as pd

from svgutils.transform import fromfile, SVGFigure
import cairosvg

def _to_px(value: str | None) -> float:
    """
    Convertit une longueur SVG (px, mm, cm, pt, in) en pixels (float).

    Si `value` est None ou vide, retourne 0.
    """
    if not value:
        return 0.0
    value = value.strip()
    num = ''
    unit = ''
    for ch in value:
        if ch.isdigit() or ch in '.-':
            num += ch
        else:
            unit += ch
    if not num:
        return 0.0
    numf = float(num)
    unit = unit.strip().lower()
    if unit in ('', 'px'):
        return numf
    if unit == 'mm':
        return numf * 3.779527559055  # 96 dpi
    if unit == 'cm':
        return numf * 37.79527559055
    if unit == 'in':
        return numf * 96
    if unit == 'pt':
        return numf * 1.3333333333333  # 1 pt = 1/72 in
    # Fallback: assume pixels
    return numf


def _dims(fig) -> Tuple[float, float]:
    """
    Renvoie (width, height) de `fig` en pixels.

    1) viewBox (les 2 derniers termes)
    2) attributs width/height de la racine
    3) fig.get_size()
    """
    root = fig.root  # Correction ici : on accède à la balise <svg>
    viewbox = root.get('viewBox')
    if viewbox:
        parts = [p for p in viewbox.replace(',', ' ').split() if p]
        if len(parts) == 4:
            return float(parts[2]), float(parts[3])

    # attributs width/height sur la balise <svg>
    w_attr = root.get('width')
    h_attr = root.get('height')
    if w_attr and h_attr:
        return _to_px(w_attr), _to_px(h_attr)

    # fallback
    w, h = fig.get_size()
    return _to_px(w), _to_px(h)



def assemble_vertical(arome: Path, stations: Path, legend: Path, output: Path) -> None:
    # Charger les 3 SVG
    fig_arome = fromfile(str(arome))
    fig_stations = fromfile(str(stations))
    fig_legend = fromfile(str(legend))

    # Dimensions
    w_arome, h_arome = _dims(fig_arome)
    w_stations, h_stations = _dims(fig_stations)
    w_leg, h_leg = _dims(fig_legend)

    # Canvas global
    w_maps = max(w_arome, w_stations)
    h_maps = h_arome + h_stations
    height = h_maps  # somme des deux cartes

    # Facteur d'échelle pour que la légende fasse 1.5 fois la hauteur de la carte AROME
    scale_leg = (1.5 * h_arome) / h_leg
    w_leg_scaled = w_leg * scale_leg
    h_leg_scaled = h_leg * scale_leg  # = 1.5 * h_arome

    width = w_maps + w_leg_scaled  # légende à droite

    canvas = SVGFigure(f"{width}px", f"{height}px")
    canvas.root.set('viewBox', f"0 0 {width} {height}")

    # Racines
    root_arome = fig_arome.getroot()
    root_stations = fig_stations.getroot()
    root_legend = fig_legend.getroot()

    # Redimensionnement de la légende
    root_legend.scale(scale_leg, scale_leg)

    # Positionnement
    root_stations.moveto(0, h_arome)
    # Centrage vertical de la légende sur la hauteur totale
    y_leg = (h_maps - h_leg_scaled) / 2
    root_legend.moveto(w_maps, y_leg)

    canvas.append([root_arome, root_stations, root_legend])

    os.makedirs(os.path.dirname(str(output)), exist_ok=True)
    canvas.save(str(output))
    pdf_path = str(output)[:-4] + ".pdf"
    cairosvg.svg2pdf(url=str(output), write_to=pdf_path)
    return str(output)


def assemble(arome: Path, stations: Path, legend: Path, output: Path) -> str:
    # Charger les 2 cartes
    fig_arome = fromfile(str(arome))
    fig_stations = fromfile(str(stations))

    # Dimensions via _dims existant
    w_a, h_a = _dims(fig_arome)
    w_s, h_s = _dims(fig_stations)

    # Mise à l'échelle: même hauteur que AROME
    scale_s = h_a / h_s if h_s != 0 else 1.0
    root_a = fig_arome.getroot()
    root_s = fig_stations.getroot()
    root_s.scale(scale_s)

    w_s_scaled, h_s_scaled = w_s * scale_s, h_s * scale_s

    # Canvas côte à côte
    width  = w_a + w_s_scaled
    height = max(h_a, h_s_scaled)

    canvas = SVGFigure(f"{width}px", f"{height}px")
    canvas.root.set("viewBox", f"0 0 {width} {height}")

    # Positionnement: AROME à gauche, Stations à droite
    root_a.moveto(0, 0)
    root_s.moveto(w_a, 0)

    # Pas de légende
    canvas.append([root_a, root_s])

    os.makedirs(os.path.dirname(str(output)), exist_ok=True)
    canvas.save(str(output))
    cairosvg.svg2pdf(url=str(output), write_to=str(output)[:-4] + ".pdf")
    return str(output)

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.ticker as mticker

def combined_metrics_df(name_file: str):
    base_dir = Path("../outputs")         # dossier racine à explorer
    csv_paths = list(base_dir.rglob(name_file))

    frames = []
    for path in csv_paths:
        try:
            df = pd.read_csv(path)
            df["source"] = str(path.relative_to(base_dir))  # garder la provenance
            frames.append(df)
        except Exception as exc:                             # CSV illisible
            print(f"⚠️  Fichier ignoré {path}: {exc}")

    if not frames:
        raise SystemExit("Aucun metrics.csv trouvé !")

    # Concaténation puis export
    combined = pd.concat(frames, ignore_index=True)

    # --- harmonisation des échelles ---
    # cas quotidien_reduce
    mask_q = combined["source"].str.contains("quotidien_reduce", na=False)
    combined.loc[mask_q & (combined["echelle"] == "quotidien"), "echelle"] = "quotidien_reduce"

    # cas horaire_reduce
    mask_h = combined["source"].str.contains("horaire_reduce", na=False)
    combined.loc[mask_h & (combined["echelle"] == "horaire"), "echelle"] = "horaire_reduce"

    return combined

combined = combined_metrics_df("metrics.csv")
combined_signif = combined_metrics_df("metrics_signif.csv")
combined_signif["col_calculate"] = combined_signif["col_calculate"].astype(str) + "_signif"
combined_all = pd.concat([combined, combined_signif], ignore_index=True)


import math
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.ticker as mticker


def plot_r_by_season(
    df,
    echelles,
    col_values,          # <-- plusieurs indicateurs (ex. ['numday', 'mean', 'mean-max'])
    nom_fichier,         # préfixe du fichier (le numéro du facet est ajouté automatiquement)
    col_plot: str="r"
):
    """
    Trace un bar‑chart groupé « r » par saison, pour plusieurs indicateurs.
    Produit un seul PNG contenant un facet‑grid (nrows × ncols).

    Parameters
    ----------
    df : pandas.DataFrame
    echelles : list[str]
        Sous-ensemble d'échelles à garder (ex. ['quotidien', 'horaire'])
    col_values : list[str]
        Liste des valeurs cibles de la colonne 'col_calculate'
    nom_fichier : str
        Nom de base du fichier PNG (sans extension)
    """
    ncols=len(col_values)

    label_map = {
        "numday":  "Nombre de jour de pluie",
        "mean":    "Cumul de précipitations",
        "mean-max": "Moyenne des maxima",
        "z_T_p":   "Tendance significative et non significative",
        "z_T_p_signif":   "Tendance significative"
    }

    # ---------------------------------------------
    # 0) Préparation de la grille de sous‑graphes
    # ---------------------------------------------
    n_facets = len(col_values)
    ncols = max(1, min(ncols, n_facets))
    nrows = math.ceil(n_facets / ncols)

    fig, axes = plt.subplots(
        nrows=nrows,
        ncols=ncols,
        figsize=(12, 5 * nrows),
        sharey=True
    )
    # axes → tableau 1D pour itération uniforme
    axes = np.atleast_1d(axes).flatten()

    # Pour récupérer une seule fois handles/labels de la légende
    first_handles, first_labels = None, None

    # ------------------------------------------------------------------
    # Boucle sur chaque col_value demandé → un subplot par indicateur
    # ------------------------------------------------------------------
    for ax, col_value in zip(axes, col_values):
        # --- 1) Filtrage identique ---
        sub = df.loc[
            (df["echelle"].isin(echelles)) &
            (df["col_calculate"] == col_value),
            ["season", "echelle", col_plot]
        ]
        if sub.empty:
            ax.set_visible(False)
            ax.set_title(f"Aucune donnée pour '{col_value}'")
            continue

        sub["season"] = sub["season"].str.upper()

        # --- 2) Ordre fixe ---
        ordre_total = [
            "HYDRO", 
            "SON", "DJF", "MAM", "JJA",
            "OND", "JFM", "AMJ", "JAS",
            "SEP", "OCT", "NOV", "DEC", "JAN", "FEV", 
            "MAR", "AVR", "MAI", "JUI", "JUILL", "AOU"
        ]
        saisons_pres = [s for s in ordre_total if s in sub["season"].unique()]

        # --- 3) Renommage des échelles ---
        rename_map = {
            "quotidien":        "Journalière (1959‑2022)",
            "quotidien_reduce": "Journalière (1990‑2022)",
            "horaire":          "Horaire (1990‑2022)",
        }

        # --- 4) Pivot ---
        pivot = (
            sub.pivot(index="season", columns="echelle", values=col_plot)
               .rename(columns=rename_map)
               .reindex(saisons_pres)
        )

        # --- 5) Colonnes dans l’ordre demandé ---
        ordre_cols = [
            rename_map[k] for k in ["quotidien", "quotidien_reduce", "horaire"]
            if rename_map[k] in pivot.columns
        ]
        pivot = pivot[ordre_cols]

        # --- 6) Couleurs ---
        couleurs = ["black", "dimgray", "lightgray"][:pivot.shape[1]]

        # --- 7) Bar chart groupé ---
        x = np.arange(len(pivot))
        largeur = 0.8 / pivot.shape[1]

        for i, (col, couleur) in enumerate(zip(pivot.columns, couleurs)):

            bars = ax.bar(
                x + i * largeur,
                pivot[col],
                width=largeur,
                color=couleur,
                label=col
            )

        # --- 8) Axes, grille, ticks ---
        ax.set_xticks(
            x + largeur * (pivot.shape[1] - 1) / 2,
            pivot.index
        )
        ax.tick_params(axis='x', rotation=45)   # Rotation ici
        ax.set_xlabel("")
        if col_plot=="me":
          ax.set_ylabel("Δ (AROME - Stations) (mm/h)")
        else:
          ax.set_ylabel(col_plot)
        ax.set_title(label_map.get(col_value, col_value))   # titre lisible pour chaque subplot)

        if col_plot=="r":
          ax.set_ylim(top=1)   # <-- Forcer ymax à 1
          ax.yaxis.set_major_locator(mticker.MultipleLocator(0.1))
          ax.yaxis.set_minor_locator(mticker.MultipleLocator(0.02))
        else:
          ax.yaxis.set_major_locator(mticker.MultipleLocator(0.5))
          ax.yaxis.set_minor_locator(mticker.MultipleLocator(0.25))

        ax.grid(axis="y", which="major", linestyle="--", alpha=0.8)
        ax.grid(axis="y", which="minor", linestyle=":",  alpha=0.5)

        # mémoriser les handles/labels la première fois
        if first_handles is None:
            first_handles, first_labels = ax.get_legend_handles_labels()

        # supprimer la légende locale seulement si elle existe
        leg = ax.get_legend()
        if leg is not None:
            leg.remove()


    # ------------------------------------------------------------------
    # 9) Légende globale (ligne en‑haut, centrée)
    # ------------------------------------------------------------------
    if first_handles:
        fig.legend(
            first_handles,
            first_labels,
            loc="lower center",
            ncol=len(first_labels),
            bbox_to_anchor=(0.5, 1.02)
        )

    fig.tight_layout()
    fig.subplots_adjust(top=0.90)  # laisser de l’espace pour la légende globale

    # ------------------------------------------------------------------
    # 10) Sauvegarde
    # ------------------------------------------------------------------
    fig.savefig(f"figures/{nom_fichier}.png", dpi=500, bbox_inches="tight")
    plt.close(fig)

```



\newpage

```{python}
df_trend_pluie_hydro = combined_all.loc[(combined_all["echelle"] == "quotidien") & (combined_all["season"] == "hydro") & (combined_all["col_calculate"] == "z_T_p_signif"), ["n", "r", "me", "delta"]]

df_trend_pluie_ond = combined_all.loc[(combined_all["echelle"] == "quotidien") & (combined_all["season"] == "ond") & (combined_all["col_calculate"] == "z_T_p_signif"), ["n", "r", "me", "delta"]]

df_trend_pluie_jfm = combined_all.loc[(combined_all["echelle"] == "quotidien") & (combined_all["season"] == "jfm") & (combined_all["col_calculate"] == "z_T_p_signif"), ["n", "r", "me", "delta"]]

df_trend_pluie_amj = combined_all.loc[(combined_all["echelle"] == "quotidien") & (combined_all["season"] == "amj") & (combined_all["col_calculate"] == "z_T_p_signif"), ["n", "r", "me", "delta"]]

df_trend_pluie_jas = combined_all.loc[(combined_all["echelle"] == "quotidien") & (combined_all["season"] == "jas") & (combined_all["col_calculate"] == "z_T_p_signif"), ["n", "r", "me", "delta"]]
```



```{=latex}
\begingroup
\providecommand{\+}{+}% neutralise \+ localement
\renewcommand{\.}{.}% neutralise \. localement

% ---- Grille principale en pleine largeur (outrepasse les marges) ----
% On réduit temporairement les marges à 0.1 cm pour cette figure uniquement
\newgeometry{left=0.1cm,right=0.1cm}

\begin{center}
\noindent
\begin{minipage}[t]{\paperwidth}
  % Aucun espacement interne
  \setlength{\tabcolsep}{0pt}      % marge horizontale nulle entre colonnes
  \renewcommand{\arraystretch}{1}  % pas d’espacement vertical supplémentaire
  \begin{tabularx}{\paperwidth}{
    >{\centering\arraybackslash}m{0.49\paperwidth}
    >{\centering\arraybackslash}m{0.49\paperwidth}
  }

    % --- Ligne 1 ---
    \textbf{\small OND} & \textbf{\small JFM} \\[-0.5mm]
    \small $r =$ {`{python} f'{df_trend_pluie_ond['r'].iloc[0].item():.2f}'`} (n={`{python} f'{df_trend_pluie_ond['n'].iloc[0].item()}'`}) &
    \small $r =$ {`{python} f'{df_trend_pluie_jfm['r'].iloc[0].item():.2f}'`} (n={`{python} f'{df_trend_pluie_jfm['n'].iloc[0].item()}'`}) \\[-0.5mm]
    \small $ME =$ {`{python} f'{df_trend_pluie_ond['me'].iloc[0].item():+.2f}'`}\% &
    \small $ME =$ {`{python} f'{df_trend_pluie_jfm['me'].iloc[0].item():+.2f}'`}\% \\[-0.5mm]
    \includegraphics[width=\linewidth]{figures/trend_pluie_ond.pdf} &
    \includegraphics[width=\linewidth]{figures/trend_pluie_jfm.pdf} \\

    % --- Ligne 2 ---
    \textbf{\small AMJ} & \textbf{\small JAS} \\[-0.5mm]
    \small $r =$ {`{python} f'{df_trend_pluie_amj['r'].iloc[0].item():.2f}'`} (n={`{python} f'{df_trend_pluie_amj['n'].iloc[0].item()}'`}) &
    \small $r =$ {`{python} f'{df_trend_pluie_jas['r'].iloc[0].item():.2f}'`} (n={`{python} f'{df_trend_pluie_jas['n'].iloc[0].item()}'`}) \\[-0.5mm]
    \small $ME =$ {`{python} f'{df_trend_pluie_amj['me'].iloc[0].item():+.2f}'`}\% &
    \small $ME =$ {`{python} f'{df_trend_pluie_jas['me'].iloc[0].item():+.2f}'`}\% \\[-0.5mm]
    \includegraphics[width=\linewidth]{figures/trend_pluie_amj.pdf} &
    \includegraphics[width=\linewidth]{figures/trend_pluie_jas.pdf} \\

    % --- Ligne 3 ---
    \textbf{\small HYDRO} &
    \multirow{3}{*}{
    \begin{minipage}[c]{\linewidth}
        \centering
        % Légende pivotée : aligne verticalement avec HYDRO, r=, ME=
        \includegraphics[width=0.85\linewidth,keepaspectratio]{../outputs/maps/gev_z_T_p/quotidien/compare_9/sat_99.0/legend_horiz_signif.pdf}
        \makebox[0.85\linewidth][c]{\small \%}
    \end{minipage}
    }
    \\[-0.5mm]

    \small $r =$ {`{python} f'{df_trend_pluie_hydro['r'].iloc[0].item():.2f}'`} (n={`{python} f'{df_trend_pluie_hydro['n'].iloc[0].item()}'`}) & \\[-0.5mm]
    \small $ME =$ {`{python} f'{df_trend_pluie_hydro['me'].iloc[0].item():+.2f}'`}\% & \\[-0.5mm]

    % --- ligne de la carte + caption (nouveau bloc) ---
    \includegraphics[width=\linewidth]{figures/trend_pluie_hydro.pdf} &
    \begin{minipage}[c]{\linewidth}
    \centering
    \vspace{0.5em}
    \begin{minipage}[c]{0.90\linewidth} % <-- crée une marge interne horizontale (~5% chaque côté)
        \setlength{\parindent}{0pt}
        \small
        \captionof{figure}{
        \vspace{0.3em}
        Seasonal analysis of relative trends from 1995 to 2022 (\%) in the 10-year return level
        between the AROME model (left) and Météo-France stations (right), with the correlation ($r$),
        the number of stations compared (n), and the bias ($ME$) derived from daily precipitation maxima
        from 1959 to 2022.
        \vspace{0.3em}
        }
    \end{minipage}
    \end{minipage}
    \\

    
  \end{tabularx}
\end{minipage}
\end{center}

\restoregeometry
\endgroup
```



