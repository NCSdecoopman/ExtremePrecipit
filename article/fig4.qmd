---
title: ""
format:
  pdf:
    listings: false
    documentclass: standalone
    classoption: ["border=0pt"]
    keep-tex: true
execute:
  echo: false
  warning: false
  message: false
header-includes:
  - \usepackage{graphicx}
  - \usepackage{tabularx}
  - \usepackage{array}
  - \usepackage{makecell}
  - \usepackage{multirow}
  - \usepackage{caption}
---

```{python}
import sys
import os
from pathlib import Path

import pandas as pd
import numpy as np
import math
import matplotlib.pyplot as plt
import matplotlib.ticker as mticker

def combined_metrics_df(name_file: str, base_dir: Path = Path("../outputs")):
    csv_paths = list(base_dir.rglob(name_file))

    frames = []
    for path in csv_paths:
        try:
            df = pd.read_csv(path)
            df["source"] = str(path.relative_to(base_dir))  # garder la provenance
            frames.append(df)
        except Exception as exc:                             # CSV illisible
            print(f"⚠️  Fichier ignoré {path}: {exc}")

    if not frames:
        raise SystemExit("Aucun metrics.csv trouvé !")

    # Concaténation puis export
    combined = pd.concat(frames, ignore_index=True)

    # --- harmonisation des échelles ---
    # cas quotidien_reduce
    mask_q = combined["source"].str.contains("quotidien_reduce", na=False)
    combined.loc[mask_q & (combined["echelle"] == "quotidien"), "echelle"] = "quotidien_reduce"

    # cas horaire_reduce
    mask_h = combined["source"].str.contains("horaire_reduce", na=False)
    combined.loc[mask_h & (combined["echelle"] == "horaire"), "echelle"] = "horaire_reduce"

    return combined

combined_stats = combined_metrics_df("metrics.csv")
combined_nr = combined_metrics_df("metrics.csv", Path("../outputs_nr10"))
combined = pd.concat([combined_stats, combined_nr], ignore_index=True)

def plot_4bars_by_season(
    df: pd.DataFrame,
    seasons: list[str],
    nom_fichier: str,
    col_plot: str = "r",
):
    """
    Un seul plot : pour chaque saison, 4 barres :
      1) Number of rainy days        (numday, quotidien)
      2) Total precipitation      (mean,   quotidien)
      3) 10-year daily return level        (zTpa,   quotidien)
      4) 10-year hourly return level       (zTpa,   horaire)
    """

    # --- filtre utile ---
    sub = df.loc[df["season"].isin(seasons), ["season", "echelle", "col_calculate", col_plot]].copy()
    sub["season"] = sub["season"].str.upper()

    # ordre fixe (selon ton besoin)
    ordre_saisons = ["HYDRO", "OND", "JFM", "AMJ", "JAS", "SON", "DJF", "MAM", "JJA"]
    saisons_pres = [s.upper() for s in seasons]
    saisons_pres = [s for s in ordre_saisons if s in saisons_pres]

    # --- extraction des 4 séries ---
    def pick_one(col_calc: str, echelle: str, label: str) -> pd.Series:
        s = (
            sub.loc[(sub["col_calculate"] == col_calc) & (sub["echelle"] == echelle)]
              .set_index("season")[col_plot]
              .reindex(saisons_pres)
        )
        s.name = label
        return s

    s_rainy = pick_one("numday", "quotidien", "Number of rainy days")
    s_total = pick_one("mean",   "quotidien", "Total precipitation")
    s_rl10d = pick_one("zTpa",   "quotidien", "10-year daily return level")
    s_rl10h = pick_one("zTpa",   "horaire",   "10-year hourly return level")

    plot_df = pd.concat([s_rainy, s_total, s_rl10d, s_rl10h], axis=1)

    # --- barres groupées ---
    fig, ax = plt.subplots(figsize=(12, 5))

    x = np.arange(len(plot_df.index))
    n = plot_df.shape[1]
    width = 0.8 / n

    couleurs = ["black", "dimgray", "gray", "lightgray"][:n]

    for i, (col, c) in enumerate(zip(plot_df.columns, couleurs)):
        ax.bar(x + i * width, plot_df[col], width=width, color=c, label=col)

    ax.set_xticks(x + width * (n - 1) / 2)
    ax.set_xticklabels(plot_df.index, rotation=0)

    if col_plot == "r":
        ax.set_ylim(top=1)
        ax.yaxis.set_major_locator(mticker.MultipleLocator(0.1))
        ax.yaxis.set_minor_locator(mticker.MultipleLocator(0.02))

    ax.grid(axis="y", which="major", linestyle="--", alpha=0.8)
    ax.grid(axis="y", which="minor", linestyle=":",  alpha=0.5)

    # légende simple : pas de "daily/hourly" sur rainy/total car ce sont juste des noms de métriques
    ax.legend(loc="upper center", ncol=4, bbox_to_anchor=(0.5, 1.18), frameon=False)

    fig.tight_layout()
    fig.savefig(f"figures/{nom_fichier}.pdf", bbox_inches="tight")
    plt.close(fig)


selected_seasons = ["hydro", "ond", "jfm", "amj", "jas"]
to_plot = combined[combined["season"].isin(selected_seasons)]

plot_4bars_by_season(
    to_plot,
    seasons=selected_seasons,
    nom_fichier="histo_4bars_nr10",
    col_plot="r"
)
```

```{=latex}
\par\noindent
\makebox[\linewidth][c]{%
\includegraphics[width=\linewidth,keepaspectratio]{\detokenize{figures/histo_4bars_nr10.pdf}}%
}
\par
```