<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.36">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>La GEV</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="formules_files/libs/clipboard/clipboard.min.js"></script>
<script src="formules_files/libs/quarto-html/quarto.js"></script>
<script src="formules_files/libs/quarto-html/popper.min.js"></script>
<script src="formules_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="formules_files/libs/quarto-html/anchor.min.js"></script>
<link href="formules_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="formules_files/libs/quarto-html/quarto-syntax-highlighting-01c78b5cd655e4cd89133cf59d535862.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="formules_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="formules_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="formules_files/libs/bootstrap/bootstrap-933a14f46f0e4d1503cecf416b5e09b4.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">La GEV</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<style>
body {
  text-align: justify;
}
</style>
<section id="définition" class="level1">
<h1>Définition</h1>
<p>La loi des valeurs extrêmes généralisée (GEV) est une famille de distributions utilisée pour modéliser les maxima (ou minima) d’échantillons aléatoires. Elle englobe trois types classiques de distributions d’extrêmes (Gumbel, Fréchet, Weibull) selon la valeur du paramètre de forme.</p>
<p>Soit :</p>
<ul>
<li><span class="math inline">\(\mu\)</span> est le paramètre de position<br>
</li>
<li><span class="math inline">\(\sigma &gt; 0\)</span> est le paramètre d’échelle<br>
</li>
<li><span class="math inline">\(\xi\)</span> est le paramètre de forme</li>
</ul>
<p>La fonction de densité de probabilité (pdf) de la GEV est donnée par :</p>
<p><span class="math display">\[
{\displaystyle f(x;\mu ,\sigma ,\xi )={\frac {1}{\sigma }}\left(1+\xi \left({\frac {x-\mu }{\sigma }}\right)\right)^{-{\frac {1+\xi }{\xi }}}\exp \left(-\left(1+\xi \left({\frac {x-\mu }{\sigma }}\right)\right)^{-{\frac {1}{\xi }}}\right)}
\]</span></p>
<p>Cas limite : <span class="math inline">\(\xi \to 0\)</span> (loi de Gumbel) :</p>
<p><span class="math display">\[
{\displaystyle f(x;\mu ,\sigma ,0)={\frac {1}{\sigma }}\exp \left({\frac {\mu -x}{\sigma }}\right)\exp \left(-\exp \left({\frac {\mu -x}{\sigma }}\right)\right)}
\]</span></p>
<p>Si <span class="math inline">\(\xi &gt; 0\)</span> la loi devient une loi de Fréchet et si <span class="math inline">\(\xi &lt; 0\)</span> la loi devient une loi de Weibull inverse.</p>
<p>La fonction de répartition cumulative (CDF) de la GEV est définie comme suit :</p>
<p><span class="math display">\[
F(x;\mu ,\sigma ,\xi ) = \exp \left\{ -\left[ 1 + \xi \left( \frac{x - \mu}{\sigma} \right) \right]^{-\frac{1}{\xi}} \right\}
\]</span></p>
<section id="application-aux-maxima-de-précipitations-annuels" class="level2">
<h2 class="anchored" data-anchor-id="application-aux-maxima-de-précipitations-annuels">Application aux maxima de précipitations annuels</h2>
<p>Si on note <span class="math inline">\(x\)</span> une réalisation de la variable aléatoire <span class="math inline">\(X\)</span>, représentant le maximum annuel de précipitation en un point spatial donné, alors la loi GEV est une loi de probabilité continue paramétrée par le triplet <span class="math inline">\(\theta = (\mu, \sigma, \xi)\)</span> — respectivement la position, l’échelle (strictement positive) et la forme — associant à chaque valeur <span class="math inline">\(x \to {\displaystyle f(x;\theta )={\frac {1}{\sigma }}\left(1+\xi \left({\frac {x-\mu }{\sigma }}\right)\right)^{-{\frac {1+\xi }{\xi }}}\exp \left(-\left(1+\xi \left({\frac {x-\mu }{\sigma }}\right)\right)^{-{\frac {1}{\xi }}}\right)}\)</span>.</p>
<p>On dispose d’une série temporelle de <span class="math inline">\(n\)</span> maximas annuels indépendants de précipitations pour un point géographique (exemple une station ou un pixel de modèle AROME 2,5 x 2,5 km). Ces observations sont notées <span class="math inline">\(\{x_1, x_2, \dots, x_n\}\)</span> où chaque <span class="math inline">\(x_i\)</span> est un maximum annuel de précipitation observé à l’année <span class="math inline">\(t_i\)</span> et qui suit une loi GEV de paramètre <span class="math inline">\(\theta\)</span>.</p>
</section>
<section id="transformation-de-la-covariable-temporelle" class="level2">
<h2 class="anchored" data-anchor-id="transformation-de-la-covariable-temporelle">Transformation de la covariable temporelle</h2>
<p>Pour introduire une dépendance temporelle dans les paramètres de la loi GEV, on transforme l’année <span class="math inline">\(t_i\)</span> en une covariable normalisée. Cette transformation est simplement réalisée pour des raisons numériques mais elle ne change rien au résultat théorique.</p>
<p><span class="math display">\[
\tilde{t}_i = \frac{t_i - t_{\min}}{t_{\max} - t_{\min}}
\]</span></p>
<ul>
<li><span class="math inline">\(t_i\)</span> : l’année réelle de l’observation <span class="math inline">\(x_i\)</span> (par exemple 1980, 1981, …, 2022)<br>
</li>
<li><span class="math inline">\(t_{min} = \min_i t_i\)</span><br>
</li>
<li><span class="math inline">\(t_{max} = \max_i t_i\)</span></li>
</ul>
<p>On crée également une covariable temporelle avec point de rupture noté <span class="math inline">\(t_+\)</span> tel que :</p>
<p><span class="math display">\[
\tilde{t}^\ast =
\begin{cases}
0 &amp; \text{si } t_i &lt; t_+ \\
\displaystyle \frac{t_i - t_+}{t_{\max} - t_+} &amp; \text{si } t_i \ge t_+
\end{cases}
\]</span></p>
<p>Ce codage permet d’appliquer une pente temporelle seulement après la date de rupture, avec une covariable encore normalisée sur <span class="math inline">\([0,1]\)</span> dans la portion post-rupture.</p>
</section>
</section>
<section id="statistiques" class="level1">
<h1>Statistiques</h1>
<p>Soit <span class="math inline">\({\displaystyle g_{k}=\Gamma (1-k\xi )}\)</span> avec <span class="math inline">\({\displaystyle k\in \{1,2,3,4\}}\)</span> et <span class="math inline">\({\displaystyle \Gamma }\)</span> la fonction gamma. L’espérance, la variance et le mode d’une variable suivant la loi d’extremum généralisée peuvent s’exprimer par :</p>
<p><span class="math inline">\({\displaystyle \mathbb {E} (X)=\mu +{\frac {\sigma }{\xi }}(g_{1}-1)}\)</span></p>
<p><span class="math inline">\({\displaystyle \mathbb {V} (X)={\frac {\sigma ^{2}}{\xi ^{2}}}(g_{2}-g_{1}^{2})}\)</span></p>
<p><span class="math inline">\({\displaystyle \operatorname {Mode} (X)=\mu +{\frac {\sigma }{\xi }}[(1+\xi )^{-\xi }-1]}\)</span></p>
</section>
<section id="vraisemblance" class="level1">
<h1>Vraisemblance</h1>
<p>Soit la fonction de vraisemblance <span class="math inline">\({\displaystyle {\mathcal {L}}(\theta ;x)} : {\displaystyle \theta \mapsto f(x;\theta )}\)</span>.</p>
<p>Soit :</p>
<p><span class="math display">\[
{\displaystyle \log {\mathcal {L}}(\theta ;x_{1},x_{2},\dots ,x_{n})=\sum _{i=1}^{n}\log {\mathcal {L}}(\theta ;x_{i})}
\]</span></p>
<p>Pour <span class="math inline">\(1 + \xi \frac{x - \mu}{\sigma} &gt; 0\)</span>, avec <span class="math inline">\(\sigma &gt; 0\)</span> :</p>
<p><span class="math display">\[
\begin{aligned}
\log \mathcal{L}(\theta)
&amp;= \sum_{i=1}^n \left[
  -\log \sigma
  - \frac{1 + \xi}{\xi} \log\left(1 + \xi \frac{x_i - \mu}{\sigma} \right)
  - \left(1 + \xi \frac{x_i - \mu}{\sigma} \right)^{-\frac{1}{\xi}}
\right] \\
\log \mathcal{L}(\theta)
&amp;= -n \log \sigma
- \left(1 + \frac{1}{\xi}\right) \sum_{i=1}^n \log\left(1 + \xi \frac{x_i - \mu}{\sigma} \right)
- \sum_{i=1}^n \left(1 + \xi \frac{x_i - \mu}{\sigma} \right)^{-\frac{1}{\xi}}
\end{aligned}
\]</span></p>
<p>On note :</p>
<p><span class="math display">\[
z_i(\theta)=1+\xi\;\frac{x_i-\mu}{\sigma}
\]</span></p>
<p>La log-vraisemblance <span class="math inline">\(\ell(\theta) = \log \mathcal{L}(\theta)\)</span> s’écrit alors :</p>
<p><span class="math display">\[
\boxed{\;
\ell(\theta)=
-\sum_{i=1}^n\Bigl[
\log\sigma
+\Bigl(1+\tfrac1{\xi}\Bigr)\log z_i
+z_i^{-\frac{1}{\xi}}
\Bigr]
\;}
\tag{1}
\]</span></p>
</section>
<section id="modèles" class="level1">
<h1>Modèles</h1>
<p>Soit <span class="math inline">\(t \in \mathbb{N} \mid t_{\min} \leq t \leq t_{\max}\)</span>.</p>
<section id="stationnaire" class="level2">
<h2 class="anchored" data-anchor-id="stationnaire">Stationnaire</h2>
<p>Le modèle stationnaire noté <span class="math inline">\(M_0(\mu_0, \sigma_0)\)</span> et <span class="math inline">\(\theta_0 = (\mu_0, \sigma_0, \xi_0)\)</span> est défini par :</p>
<p><span class="math display">\[
\left\{
\begin{array}{l}
\mu(t) = \mu_0 \\
\sigma(t) = \sigma_0 \\
\xi(t) = \xi_0
\end{array}
\right.
\]</span></p>
</section>
<section id="non-stationnaire" class="level2">
<h2 class="anchored" data-anchor-id="non-stationnaire">Non stationnaire</h2>
<p>Les modèles non stationnaires sont définis suivant la présence ou non d’un point de rupture</p>
<section id="sans-point-de-rupture" class="level3">
<h3 class="anchored" data-anchor-id="sans-point-de-rupture">Sans point de rupture</h3>
<p>On note <span class="math inline">\(M_1(\theta_1)\)</span> et <span class="math inline">\(\theta_1 = (\mu_0, \mu_1, \sigma_0, \xi_0)\)</span> :</p>
<p><span class="math display">\[
\left\{
\begin{array}{l}
\mu(t) = \mu_0 + \mu_1 \cdot t \\
\sigma(t) = \sigma_0 \\
\xi(t) = \xi_0
\end{array}
\right.
\]</span></p>
<p>On note <span class="math inline">\(M_2(\theta_2)\)</span> et <span class="math inline">\(\theta_2 = (\mu_0, \sigma_0, \sigma_1, \xi_0)\)</span> :</p>
<p><span class="math display">\[
\left\{
\begin{array}{l}
\mu(t) = \mu_0 \\
\sigma(t) = \sigma_0 + \sigma_1 \cdot t \\
\xi(t) = \xi_0
\end{array}
\right.
\]</span></p>
<p>On note <span class="math inline">\(M_3(\theta_3)\)</span> et <span class="math inline">\(\theta_3 = (\mu_0, \mu_1, \sigma_0, \sigma_1, \xi_0)\)</span> :</p>
<p><span class="math display">\[
\left\{
\begin{array}{l}
\mu(t) = \mu_0 + \mu_1 \cdot t\\
\sigma(t) = \sigma_0 + \sigma_1 \cdot t \\
\xi(t) = \xi_0
\end{array}
\right.
\]</span></p>
</section>
<section id="avec-point-de-rupture" class="level3">
<h3 class="anchored" data-anchor-id="avec-point-de-rupture">Avec point de rupture</h3>
<p>On reprend la notation du point de rupture noté <span class="math inline">\(t_+\)</span>. Cette fois :</p>
<p><span class="math display">\[
t^\ast = t \cdot \mathbb{1}_{t &gt; t_+} \quad \text{avec } t_+ \in \mathbb{N}
\]</span></p>
<p>Les modèles <span class="math inline">\(M_1\)</span>, <span class="math inline">\(M_2\)</span> et <span class="math inline">\(M_3\)</span> deviennent respectivements <span class="math inline">\(M_1^\ast\)</span>, <span class="math inline">\(M_2^\ast\)</span> et <span class="math inline">\(M_3^\ast\)</span>. On note sur ce même principe <span class="math inline">\(\theta_i\)</span> qui devient <span class="math inline">\(\theta^\ast_i\)</span> avec <span class="math inline">\(i \in \{1, 2, 3\}\)</span>.</p>
</section>
</section>
<section id="vraisemblances" class="level2">
<h2 class="anchored" data-anchor-id="vraisemblances">Vraisemblances</h2>
<p><span class="math display">\[
\boxed{\;
\begin{aligned}
\ell_{M_0}(\mu_0, \sigma_0, \xi_0) &amp;=
-\sum_{i=1}^n \left[
\log \sigma_0 +
\left(1 + \frac{1}{\xi_0} \right) \log \left(1 + \xi_0 \frac{x_i - \mu_0}{\sigma_0} \right) +
\left(1 + \xi_0 \frac{x_i - \mu_0}{\sigma_0} \right)^{-1/\xi_0}
\right]\\
\ell_{M_1}(\mu_0, \mu_1, \sigma_0, \xi_0) &amp;=
-\sum_{i=1}^n \left[
\log \sigma_0 +
\left(1 + \frac{1}{\xi_0} \right) \log \left(1 + \xi_0 \frac{x_i - (\mu_0 + \mu_1 \cdot \tilde{t}_i)}{\sigma_0} \right) +
\left(1 + \xi_0 \frac{x_i - (\mu_0 + \mu_1 \cdot \tilde{t}_i)}{\sigma_0} \right)^{-1/\xi_0}
\right]\\
\ell_{M_2}(\mu_0, \sigma_0, \sigma_1, \xi_0) &amp;=
-\sum_{i=1}^n \left[
\log (\sigma_0 + \sigma_1 \tilde{t}_i) +
\left(1 + \frac{1}{\xi_0} \right) \log \left(1 + \xi_0 \frac{x_i - \mu_0}{\sigma_0 + \sigma_1 \tilde{t}_i} \right) +
\left(1 + \xi_0 \frac{x_i - \mu_0}{\sigma_0 + \sigma_1 \tilde{t}_i} \right)^{-1/\xi_0}
\right]\\
\ell_{M_3}(\mu_0, \mu_1, \sigma_0, \sigma_1, \xi_0) &amp;=
-\sum_{i=1}^n \left[
\log (\sigma_0 + \sigma_1 \tilde{t}_i) +
\left(1 + \frac{1}{\xi_0} \right) \log \left(1 + \xi_0 \frac{x_i - (\mu_0 + \mu_1 \tilde{t}_i)}{\sigma_0 + \sigma_1 \tilde{t}_i} \right) +
\left(1 + \xi_0 \frac{x_i - (\mu_0 + \mu_1 \tilde{t}_i)}{\sigma_0 + \sigma_1 \tilde{t}_i} \right)^{-1/\xi_0}
\right]
\end{aligned}
\;}
\tag{1'}
\]</span></p>
<p>Pour les modèles avec point de rupture, on remplace <span class="math inline">\(\tilde{t}_i\)</span> par <span class="math inline">\(\tilde{t}_i^*\)</span> :</p>
<p><span class="math display">\[
\tilde{t}_i^* =
\begin{cases}
0 &amp; \text{si } t_i &lt; t_+ \\
\frac{t_i - t_+}{t_{\max} - t_+} &amp; \text{si } t_i \ge t_+
\end{cases}
\]</span></p>
<p>Les vraisemblances de <span class="math inline">\(M_1^*, M_2^*, M_3^*\)</span> sont obtenues en remplaçant <span class="math inline">\(\tilde{t}_i \to \tilde{t}_i^*\)</span> dans les expressions ci-dessus.</p>
</section>
<section id="maximum-de-vraisemblance" class="level2">
<h2 class="anchored" data-anchor-id="maximum-de-vraisemblance">Maximum de vraisemblance</h2>
<p>En pratique, les paramètres <span class="math inline">\((\mu, \sigma, \xi)\)</span> sont inconnus et estimés à partir des données par un estimateur <span class="math inline">\(\hat{\theta} = (\hat{\mu}, \hat{\sigma}, \hat{\xi})\)</span> obtenu par maximum de vraisemblance via une optimisation numérique. Il n’existe pas de formule explicite des paramètres.</p>
<p><span class="math display">\[
\hat{\theta} = \arg\max_{\theta} \, \ell(\theta)
\]</span></p>
</section>
</section>
<section id="niveau-de-retour-en-loi-gev" class="level1">
<h1>Niveau de retour en loi GEV</h1>
<section id="estimation" class="level2">
<h2 class="anchored" data-anchor-id="estimation">Estimation</h2>
<p>Le niveau de retour (ou quantile d’ordre <span class="math inline">\(1 - \tfrac{1}{T}\)</span>) dans une loi GEV correspond à une valeur seuil <span class="math inline">\(z_T\)</span> que l’on dépasse, en moyenne, une fois tous les <span class="math inline">\(T\)</span> ans.</p>
<p>Soit <span class="math inline">\(X \sim \mathrm{GEV}(\mu, \sigma, \xi)\)</span>, alors :</p>
<p><span class="math display">\[
\mathbb{P}(X &gt; z_T) = \frac{1}{T}, \quad \text{soit} \quad z_T = F^{-1}\left(1 - \frac{1}{T} \right)
\]</span></p>
<p>où <span class="math inline">\(F^{-1}\)</span> est la fonction quantile de la GEV. On obtient une formule explicite selon <span class="math inline">\(\xi\)</span> :</p>
<ul>
<li>Si <span class="math inline">\(\xi \ne 0\)</span> :</li>
</ul>
<p><span class="math display">\[
z_T = \mu + \frac{\sigma}{\xi} \left[ \left( -\log\left(1 - \frac{1}{T}\right) \right)^{-\xi} - 1 \right]
\]</span></p>
<ul>
<li>Si <span class="math inline">\(\xi = 0\)</span> (cas de Gumbel) :</li>
</ul>
<p><span class="math display">\[
z_T = \mu - \sigma \log \left( -\log\left(1 - \frac{1}{T} \right) \right)
\]</span></p>
<p>Ainsi, l’estimateur du niveau de retour <span class="math inline">\(\hat{z}_T\)</span> s’écrit :</p>
<p><span class="math display">\[
\hat{z}_{T}\;=\;F^{-1}_{\hat{\theta}}\!\left(1-\frac{1}{T}\right)
\]</span></p>
<p>Le MLE classique donne un point estimé, mais pas d’intervalle.</p>
<ul>
<li><span class="math inline">\(z_{10}\)</span> est la valeur de précipitation (ou autre variable extrême) que l’on s’attend à dépasser <strong>en moyenne une fois tous les 10 ans</strong>.</li>
<li>Cela <strong>n’implique pas</strong> que la valeur ne peut pas être dépassée plusieurs années de suite : la probabilité de dépassement reste de <span class="math inline">\(\frac{1}{T}\)</span> <strong>chaque année</strong>, indépendamment.</li>
</ul>
<p>Pour <span class="math inline">\(\mu = 20\)</span>, <span class="math inline">\(\sigma = 5\)</span>, <span class="math inline">\(\xi = 0{,}2\)</span> et <span class="math inline">\(T = 50\)</span> ans :</p>
<p><span class="math display">\[
z_{50} = 20 + \frac{5}{0{,}2} \left[ \left( -\log\left(1 - \frac{1}{50} \right) \right)^{-0{,}2} - 1 \right]
\]</span></p>
</section>
<section id="vraisemblance-profilée" class="level2">
<h2 class="anchored" data-anchor-id="vraisemblance-profilée">Vraisemblance profilée</h2>
<p>On souhaite aussi connaître l’incertitude autour de l’estimation de <span class="math inline">\(\hat{z}_T\)</span>. Pour cela, on utilise la vraisemblance profilée.</p>
<p>On cherche à estimer un intervalle de confiance pour le niveau de retour <span class="math inline">\(z_T\)</span>, défini par :</p>
<p><span class="math display">\[
z_T = F^{-1}_{\theta}\left(1 - \frac{1}{T}\right) = \mu + \dfrac{\sigma}{\xi} \left[ \left( -\log\left(1 - \frac{1}{T} \right) \right)^{-\xi} - 1 \right] \quad \text{si } \xi \ne 0
\]</span></p>
<p>Qui peut se réecrire sous la forme :</p>
<p><span class="math display">\[
\mu = z_T - \dfrac{\sigma}{\xi} \left[ \left( -\log\left(1 - \frac{1}{T} \right) \right)^{-\xi} - 1 \right]
\]</span></p>
<p>La combinaison des paramètres temporels de la loi GEV conduit à une expression linéaire en <span class="math inline">\(t\)</span> alors : <span class="math inline">\(z_T(t) = z_{T,0} + z_{T,1} \cdot t\)</span></p>
<p>En développant les paramètres soumis à un effet temporel, on a :</p>
<p><span class="math display">\[
\begin{aligned}
\mu_0 + \mu_1 t &amp;= z_{T,0} + z_{T,1} t - \dfrac{\sigma_0 + \sigma_1 t}{\xi_0} \left[ \left( -\log\left(1 - \frac{1}{T} \right) \right)^{-\xi_0} - 1 \right]\\
\mu_0+\mu_1\,t &amp;= \Bigl[\,z_{T,0}
-\dfrac{\sigma_0}{\xi_0}\Bigl(\bigl[-\log(1-\tfrac1T)\bigr]^{-\xi_0}-1\Bigr)
\Bigr]\;+\;\Bigl[\,z_{T,1}-\dfrac{\sigma_1}{\xi_0}\Bigl(\bigl[-\log(1-\tfrac1T)\bigr]^{-\xi_0}-1\Bigr)\Bigr]\,t\\
\end{aligned}
\]</span></p>
<p>c’est-à-dire, terme à terme :</p>
<p><span class="math display">\[
\begin{aligned}
\mu_0 &amp;\;=\; z_{T,0}
-\dfrac{\sigma_0}{\xi_0}\Bigl(\bigl[-\log(1-\tfrac1T)\bigr]^{-\xi_0}-1\Bigr),\\[0.8em]
\mu_1 &amp;\;=\; z_{T,1}
-\dfrac{\sigma_1}{\xi_0}\Bigl(\bigl[-\log(1-\tfrac1T)\bigr]^{-\xi_0}-1\Bigr).
\end{aligned}
\]</span></p>
<p>On écrit :</p>
<p><span class="math display">\[
\begin{aligned}
\mu_1(z_{T,1}) &amp;= z_{T,1} -\dfrac{\hat{\sigma_1}}{\hat{\xi}_0}\Bigl(\bigl[-\log(1-\tfrac1T)\bigr]^{-\hat{\xi}_0}-1\Bigr)\\
\sigma_1(z_{T,1}) &amp;= \dfrac{\hat{\xi}_0\,\bigl(z_{T,1}-\hat{\mu_1}\bigr)}{\bigl[-\log\!\bigl(1-\tfrac1T\bigr)\bigr]^{-\hat{\xi}_0}-1}\\
\end{aligned}
\]</span></p>
<p>On cherche l’intervalle de confiance sur <span class="math inline">\(z_{T,1}\)</span> donc pour chaque valeur candidate <span class="math inline">\(z_{T,1}\)</span> dans une grille (autour de l’estimateur <span class="math inline">\(\hat{z}_{T,1}\)</span>), on maximise les log-vraisemblances <strong><span class="math inline">\(\text{(1$'$)}\)</span></strong> qui deviennent des log-vraisemblances profilées <span class="math inline">\(\ell^{\,p}\)</span> :</p>
<p><span class="math display">\[
\boxed{\;
\begin{aligned}
\underset{\hat{\sigma}_1 = 0}{\ell_{M_1}^{\,p}(z_{T,1} \ ; \hat{\mu}_0, \hat{\sigma}_0, \hat{\xi}_0)} &amp;=
-\sum_{i=1}^n \left[
\log \hat{\sigma}_0 +
\left(1 + \frac{1}{\hat{\xi}_0} \right) \log \left(1 + \hat{\xi}_0 \frac{x_i - (\hat{\mu}_0 + \mu_1(z_{T,1}) \cdot \tilde{t}_i)}{\hat{\sigma}_0} \right) +
\left(1 + \hat{\xi}_0 \frac{x_i - (\hat{\mu}_0 + \mu_1(z_{T,1}) \cdot \tilde{t}_i)}{\hat{\sigma}_0} \right)^{-1/\hat{\xi}_0}
\right]\\
\underset{\hat{\mu}_1 = 0}{\ell_{M_2}^{\,p}(z_{T,1} \ ; \hat{\mu}_0, \hat{\sigma}_0, \hat{\xi}_0)} &amp;=
-\sum_{i=1}^n \left[
\log (\hat{\sigma}_0 + \sigma_1(z_{T,1}) \cdot \tilde{t}_i) +
\left(1 + \frac{1}{\hat{\xi}_0} \right) \log \left(1 + \hat{\xi}_0 \frac{x_i - \hat{\mu}_0}{\hat{\sigma}_0 + \sigma_1(z_{T,1}) \cdot \tilde{t}_i} \right) +
\left(1 + \hat{\xi}_0 \frac{x_i - \hat{\mu}_0}{\hat{\sigma}_0 + \sigma_1(z_{T,1}) \cdot \tilde{t}_i} \right)^{-1/\hat{\xi}_0}
\right]\\
\ell_{M_3}^{\,p}(z_{T,1} \ ; \hat{\mu}_0, \hat{\sigma}_0, \hat{\sigma}_1, \hat{\xi}_0) &amp;=
-\sum_{i=1}^n \left[
\log (\hat{\sigma}_0 + \hat{\sigma}_1 \tilde{t}_i) +
\left(1 + \frac{1}{\hat{\xi}_0} \right) \log \left(1 + \hat{\xi}_0 \frac{x_i - (\hat{\mu}_0 + \mu_1(z_{T,1}) \tilde{t}_i)}{\hat{\sigma}_0 + \hat{\sigma}_1 \tilde{t}_i} \right) +
\left(1 + \hat{\xi}_0 \frac{x_i - (\hat{\mu}_0 + \mu_1(z_{T,1}) \tilde{t}_i)}{\hat{\sigma}_0 + \hat{\sigma}_1 \tilde{t}_i} \right)^{-1/\hat{\xi}_0}
\right]\\
\end{aligned}
\;}
\]</span></p>
<p>On cherche donc :</p>
<p><span class="math display">\[
\hat{z}_{T,1} = \underset{z_{T,1}}{\arg\max} \; \ell_{M_\bullet}^{\,p}(z_{T,1} \ ; \hat{\theta}_{\bullet})
\]</span></p>
<p>Avec :</p>
<p><span class="math display">\[
\hat{\theta}_{\bullet} = \begin{cases}
\hat{\theta}_{1}^{\,p} = (\hat{\mu_0}, \hat{\sigma_0}, \hat{\xi_0}) &amp; \text{pour } M_1 \\
\hat{\theta}_2^{\,p} = (\hat{\mu_0}, \hat{\sigma_0}, \hat{\xi_0}) &amp; \text{pour } M_2 \\
\hat{\theta}_3^{\,p} = (\hat{\mu_0}, \hat{\sigma_0}, \hat{\sigma_1}, \hat{\xi_0}) &amp; \text{pour } M_3 \\
\end{cases}
\]</span></p>
<p>On trace ainsi pour chaque modèle <span class="math inline">\(M_\bullet\)</span> la fonction <span class="math inline">\({\displaystyle \mathcal{L}_{M_\bullet} : z_{T,1} {\mapsto} \ell_{M_\bullet}^{\,p}(z_{T,1} \ ; \hat{\theta}_{\bullet})}\)</span></p>
</section>
</section>
<section id="intervalle" class="level1">
<h1>Intervalle</h1>
<p>L’intervalle de confiance de <span class="math inline">\(\hat{z}_{T,1}\)</span> pour un modèle <span class="math inline">\(M_\bullet\)</span> au seuil <span class="math inline">\((1 - \alpha)\)</span> basé sur le profil de vraisemblance est donné par :</p>
<p><span class="math display">\[
\operatorname{IC}_{M_\bullet}^{(1-\alpha)}\!\bigl(\hat{z}_{T,1}\bigr)
   = \Bigl\{\, z_{T,1}\;:\;
        2\bigl[\ell_{M_\bullet}^{\,p}(\hat{z}_{T,1} \ ; \hat{\theta}_{\bullet})-\ell_{M_\bullet}^{\,p}(z_{T,1} \ ; \hat{\theta}_{\bullet})\bigr]
        \le \chi^{2}_{1,\,1-\alpha} \Bigr\}
\]</span></p>
<p>où <span class="math inline">\(\chi^2_{1,1-\alpha}\)</span> est le quantile d’ordre <span class="math inline">\(1 - \alpha\)</span> d’une loi du <span class="math inline">\(\chi^2\)</span> à un degré de liberté (≈ 2.71 pour un IC à 90 %)</p>

</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>